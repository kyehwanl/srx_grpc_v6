

Calling Go Functions from Other Languages using C Shared Libraries
==================================================================
(https://github.com/vladimirvivien/go-cshared-examples)
(https://github.com/vladimirvivien/go-cshared-examples/blob/master/README.md)



This respository contains source examples for the article Calling Go Functions from Other Languages (medium.com). 
Using the -buildmode=c-shared build flag, the compiler outputs a standard shared object binary file (.so) exposing 
Go functions as a C-style APIs. This lets programmers create Go libraries that can be called from other languages 
including C, Python, Ruby, Node, and Java (see contributed example for Lua) as done in this repository.

-----------
The Go Code
-----------
First, let us write the Go code. Assume that we have written an awesome Go library that we want to make available to other languages. 
There are four requirements to follow before compiling the code into a shared library:

- The package must be amain package. The compiler will build the package and all of its dependencies into a single shared object binary.
- The source must import the pseudo-package “C”.
- Use the //export comment to annotate functions you wish to make accessible to other languages.
- An empty main function must be declared.

The following Go source exports four functions Add, Cosine, Sort, and Log. Admittedly, the awesome library is not that impressive. 
However, its diverse function signatures will help us explore type mapping implications.

File <awesome.go>

    package main

    import "C"

    import (
        "fmt"
        "math"
        "sort"
        "sync"
    )

    var count int
    var mtx sync.Mutex

    //export Add
    func Add(a, b int) int {
        return a + b
    }

    //export Cosine
    func Cosine(x float64) float64 {
        return math.Cos(x)
    }

    //export Sort
    func Sort(vals []int) {
        sort.Ints(vals)
    }

    //export Log
    func Log(msg string) int {
        mtx.Lock()
        defer mtx.Unlock()
        fmt.Println(msg)
        count++
        return count
    }

    func main() {}


The package is compiled using the -buildmode=c-shared build flag to create the shared object binary:

    go build -o awesome.so -buildmode=c-shared awesome.go

Upon completion, the compiler outputs two files: awesome.h, a C header file and awesome.so, the shared object file, shown below:

    -rw-rw-r —    1362 Feb 11 07:59 awesome.h
    -rw-rw-r — 1997880 Feb 11 07:59 awesome.so

Notice that the .so file is around 2 Mb, relatively large for such a small library. 
This is because the entire Go runtime machinery and dependent packages are crammed into a single shared object binary 
(similar to compiling a single static executable binary).

<The header file>
The header file defines C types mapped to Go compatible types using cgo semantics.

    /* Created by “go tool cgo” — DO NOT EDIT. */
    ...
    typedef signed char GoInt8;
    typedef unsigned char GoUint8;
    typedef short GoInt16;
    typedef unsigned short GoUint16;
    typedef int GoInt32;
    typedef unsigned int GoUint32;
    typedef long long GoInt64;
    typedef unsigned long long GoUint64;
    typedef GoInt64 GoInt;
    typedef GoUint64 GoUint;
    typedef __SIZE_TYPE__ GoUintptr;
    typedef float GoFloat32;
    typedef double GoFloat64;
    typedef float _Complex GoComplex64;
    typedef double _Complex GoComplex128;

    /*
      static assertion to make sure the file is being used on architecture
      at least with matching size of GoInt.
    */
    typedef char _check_for_64_bit_pointer_matching_GoInt[sizeof(void*)==64/8 ? 1:-1];

    typedef struct { const char *p; GoInt n; } GoString;
    typedef void *GoMap;
    typedef void *GoChan;
    typedef struct { void *t; void *v; } GoInterface;
    typedef struct { void *data; GoInt len; GoInt cap; } GoSlice;

    #endif

    /* End of boilerplate cgo prologue.  */

    #ifdef __cplusplus
    extern "C" {
    #endif


    extern GoInt Add(GoInt p0, GoInt p1);

    extern GoFloat64 Cosine(GoFloat64 p0);

    extern void Sort(GoSlice p0);

    extern GoInt Log(GoString p0);

    #ifdef __cplusplus
    }
    #endif

<The shared object file>
The other file generated by the compiler is a 64-bit ELF shared object binary file. 
We can verify its information using the file command.

    $> file awesome.so
    awesome.so: ELF 64-bit LSB shared object, x86–64, version 1 (SYSV), dynamically linked, BuildID[sha1]=1fcf29a2779a335371f17219fffbdc47b2ed378a, not stripped

Using the nm and the grep commands, we can ensure our Go functions got exported in the shared object file.

    $> nm awesome.so | grep -e "T Add" -e "T Cosine" -e "T Sort" -e "T Log"
    00000000000d0db0 T Add
    00000000000d0e30 T Cosine
    00000000000d0f30 T Log
    00000000000d0eb0 T Sort


From C
------
There are two ways to use the shared object library to call Go functions from C. 
First, we can statically bind the shared library at compilation, but dynamically link it at runtime. 
Or, have the Go function symbols be dynamically loaded and bound at runtime.

(1) Dynamically linked
In this approach, we use the header file to statically reference types and functions exported in the shared object file. 
The code is simple and clean as shown below:

<File client1.c>

    #include <stdio.h>
    #include "awesome.h"

    int main() {
        printf("Using awesome lib from C:\n");
       
        //Call Add() - passing integer params, interger result
        GoInt a = 12;
        GoInt b = 99;
        printf("awesome.Add(12,99) = %d\n", Add(a, b)); 

        //Call Cosine() - passing float param, float returned
        printf("awesome.Cosine(1) = %f\n", (float)(Cosine(1.0)));
        
        //Call Sort() - passing an array pointer
        GoInt data[6] = {77, 12, 5, 99, 28, 23};
        GoSlice nums = {data, 6, 6};
        Sort(nums);
        printf("awesome.Sort(77,12,5,99,28,23): ");
        for (int i = 0; i < 6; i++){
            printf("%d,", ((GoInt *)nums.data)[i]);
        }
        printf("\n");

        //Call Log() - passing string value
        GoString msg = {"Hello from C!", 13};
        Log(msg);
    }

Next we compile the C code, specifying the shared object library:

    $> gcc -o client client1.c ./awesome.so

When the resulting binary is executed, it links to the awesome.so library, 
calling the functions that were exported from Go as the output shows below.

    $> ./client
    awesome.Add(12,99) = 111
    awesome.Cosine(1) = 0.540302
    awesome.Sort(77,12,5,99,28,23): 5,12,23,28,77,99,
    Hello from C!


(2) Dynamically Loaded
In this approach, the C code uses the dynamic link loader library (libdl.so) to dynamically load and bind exported symbols. 
It uses functions defined in dhfcn.h such as dlopen to open the library file, dlsym to look up a symbol, dlerror to retrieve 
errors, and dlclose to close the shared library file.

Because the binding and linking is done in your source code, this version is lengthier. 
However, it is doing the same thing as before, as highlighted in the following snippet 
(some print statements and error handling omitted).

<File client2.c>

    #include <stdlib.h>
    #include <stdio.h>
    #include <dlfcn.h>

    // define types needed
    typedef long long go_int;
    typedef double go_float64;
    typedef struct{void *arr; go_int len; go_int cap;} go_slice;
    typedef struct{const char *p; go_int len;} go_str;

    int main(int argc, char **argv) {
        void *handle;
        char *error;

        // use dlopen to load shared object
        handle = dlopen ("./awesome.so", RTLD_LAZY);
        if (!handle) {
            fputs (dlerror(), stderr);
            exit(1);
        }
        
        // resolve Add symbol and assign to fn ptr
        go_int (*add)(go_int, go_int)  = dlsym(handle, "Add");
        if ((error = dlerror()) != NULL)  {
            fputs(error, stderr);
            exit(1);
        }
        // call Add()
        go_int sum = (*add)(12, 99); 
        printf("awesome.Add(12, 99) = %d\n", sum);

        // resolve Cosine symbol
        go_float64 (*cosine)(go_float64) = dlsym(handle, "Cosine");
        if ((error = dlerror()) != NULL)  {
            fputs(error, stderr);
            exit(1);
        }
        // Call Cosine
        go_float64 cos = (*cosine)(1.0);
        printf("awesome.Cosine(1) = %f\n", cos);

        // resolve Sort symbol
        void (*sort)(go_slice) = dlsym(handle, "Sort");
        if ((error = dlerror()) != NULL)  {
            fputs(error, stderr);
            exit(1);
        }
        // call Sort
        go_int data[5] = {44,23,7,66,2};
        go_slice nums = {data, 5, 5};
        sort(nums);
        printf("awesome.Sort(44,23,7,66,2): ");
        for (int i = 0; i < 5; i++){
            printf("%d,", ((go_int *)data)[i]);
        }
        printf("\n");

        // resolve Log symbol
        go_int (*log)(go_str) = dlsym(handle, "Log");
        if ((error = dlerror()) != NULL)  {
            fputs(error, stderr);
            exit(1);
        }
        // call Log
        go_str msg = {"Hello from C!", 13};
        log(msg);
        
        // close file handle when done
        dlclose(handle);
    }

In the previous code, we define our own subset of Go compatible C types go_int, go_float, go_slice, and go_str. 
We use dlsym to load symbols Add, Cosine, Sort, and Log and assign them to their respective function pointers. 
Next, we compile the code linking it with the dl library (not the awesome.so) as follows:

    $> gcc -o client client2.c -ldl

When the code is executed, the C binary loads and links to shared library awesome.so producing the following output:

    $> ./client
    awesome.Add(12, 99) = 111
    awesome.Cosine(1) = 0.540302
    awesome.Sort(44,23,7,66,2): 2,7,23,44,66,
    Hello from C!





------------
From Python
------------

In Python things get a little easier. We use can use the ctypes foreign function library to call Go functions 
from the the awesome.so shared library as shown in the following snippet (some print statements are omitted).

<File client.py>

    from __future__ import print_function
    from ctypes import *

    lib = cdll.LoadLibrary("./awesome.so")

    # describe and invoke Add()
    lib.Add.argtypes = [c_longlong, c_longlong]
    lib.Add.restype = c_longlong
    print("awesome.Add(12,99) = %d" % lib.Add(12,99))

    # describe and invoke Cosine()
    lib.Cosine.argtypes = [c_double]
    lib.Cosine.restype = c_double
    print("awesome.Cosine(1) = %f" % lib.Cosine(1))

    # define class GoSlice to map to:
    # C type struct { void *data; GoInt len; GoInt cap; }
    class GoSlice(Structure):
        _fields_ = [("data", POINTER(c_void_p)), ("len", c_longlong), ("cap", c_longlong)]

    nums = GoSlice((c_void_p * 5)(74, 4, 122, 9, 12), 5, 5) 

    # call Sort
    lib.Sort.argtypes = [GoSlice]
    lib.Sort.restype = None
    lib.Sort(nums)
    print("awesome.Sort(74,4,122,9,12) = %s" % [nums.data[i] for i in range(nums.len)])

    # define class GoString to map:
    # C type struct { const char *p; GoInt n; }
    class GoString(Structure):
        _fields_ = [("p", c_char_p), ("n", c_longlong)]

    # describe and call Log()
    lib.Log.argtypes = [GoString]
    lib.Log.restype = c_longlong
    msg = GoString(b"Hello Python!", 13)
    print("log id %d"% lib.Log(msg))


Note the lib variable represents the loaded symbols from the shared object file. 
We also defined Python classes GoString and GoSlice to map to their respective C struct types. 
When the Python code is executed, it calls the Go functions in the shared object producing the following output:

    $> python client.py
    awesome.Add(12,99) = 111
    awesome.Cosine(1) = 0.540302
    awesome.Sort(74,4,122,9,12) = [4, 9, 12, 74, 122]
    Hello Python!
    log id 1


-------------------------
Python CFFI (contributed)
-------------------------
The following example was contributed by @sbinet (thank you!)

Python also has a portable CFFI library that works with Python2/Python3/pypy unchanged. 
The following example uses a C-wrapper to defined the exported Go types. 
This makes the python example less opaque and even easier to understand.

<File client-cffi.py>

    from __future__ import print_function
    import sys
    from cffi import FFI

    is_64b = sys.maxsize > 2**32

    ffi = FFI()
    if is_64b: ffi.cdef("typedef long GoInt;\n")
    else:      ffi.cdef("typedef int GoInt;\n")

    ffi.cdef("""
    typedef struct {
        void* data;
        GoInt len;
        GoInt cap;
    } GoSlice;

    typedef struct {
        const char *data;
        GoInt len;
    } GoString;

    GoInt Add(GoInt a, GoInt b);
    double Cosine(double v);
    void Sort(GoSlice values);
    GoInt Log(GoString str);
    """)

    lib = ffi.dlopen("./awesome.so")

    print("awesome.Add(12,99) = %d" % lib.Add(12,99))
    print("awesome.Cosine(1) = %f" % lib.Cosine(1))

    data = ffi.new("GoInt[]", [74,4,122,9,12])
    nums = ffi.new("GoSlice*", {'data':data, 'len':5, 'cap':5})
    lib.Sort(nums[0])
    print("awesome.Sort(74,4,122,9,12) = %s" % [
        ffi.cast("GoInt*", nums.data)[i] 
        for i in range(nums.len)])

    data = ffi.new("char[]", b"Hello Python!")
    msg = ffi.new("GoString*", {'data':data, 'len':13})
    print("log id %d" % lib.Log(msg[0]))





