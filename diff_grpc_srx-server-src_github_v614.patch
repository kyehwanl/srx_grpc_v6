--- ./Makefile.am	2021-11-23 14:56:24.708374708 -0500
+++ ./Makefile.am	2021-11-22 21:25:23.365963511 -0500
@@ -11,7 +11,37 @@ TOOLS_DIR = tools
 UTIL_DIR = util
 TEST_DIR = test
 
+
+if ENABLE_GRPC_COND
+GRPC_SERVER_LIBS = -lsrx_grpc_server 
+GRPC_CLIENT_LIBS = -lsrx_grpc_client
+GRPC_LIBS = $(GRPC_SERVER_LIBS) $(GRPC_CLIENT_LIBS)
+
+#GRPC_DIR = /opt/project/gobgp_test/gowork/src/srx_grpc
+GRPC_DIR = $(grpc_dir)
+GRPC_SERVER_PATH = $(GRPC_DIR)/server
+GRPC_CLIENT_PATH = $(GRPC_DIR)/client
+
+GRPC_SERVER_LDFLAG = -L$(GRPC_SERVER_PATH) #-rpath '$(GRPC_SERVER_PATH)'
+GRPC_CLIENT_LDFLAG = -L$(GRPC_CLIENT_PATH) #-rpath '$(GRPC_CLIENT_PATH)'
+
+GRPC_SERVER_RPATH = -rpath '$(GRPC_SERVER_PATH)'
+GRPC_CLIENT_RPATH = -Wl,-rpath -Wl,$(GRPC_CLIENT_PATH)
+#GRPC_CLIENT_RPATH = -rpath '$(GRPC_CLIENT_PATH)'
+GRPC_CFLAGS = -I$(GRPC_DIR)
+
+AM_CFLAGS = -DSRX_SERVER_PACKAGE=$(PACKAGE_VERSION) \
+			$(SCA_CFLAGS) $(GRPC_CFLAGS) -std=gnu99
+else
 AM_CFLAGS = -DSRX_SERVER_PACKAGE=$(PACKAGE_VERSION) $(SCA_CFLAGS) -std=gnu99
+endif
+
+# Read the revision number of the revision file
+# This needs GNU-Make. if this is a problem, replace the 
+# assignment of SRX_REVISION=... with either an empty
+# string or the content of the revision file.
+SRX_REVISION=$(shell cat $(SRX_REVISION_FILE))
+
 
 # Used to generate the srx folder for installation - DESTDIR for RPM generation
 INC_OUT = $(DESTDIR)$(includedir)/$(SRX_DIR)
@@ -50,7 +80,18 @@ libsrx_util_la_SOURCES = \
 		     $(UTIL_DIR)/str.c \
 		     $(UTIL_DIR)/timer.c \
 		     $(UTIL_DIR)/xml_out.c
+if ENABLE_GRPC_COND
+libsrx_util_la_LIBADD = #$(GRPC_CLIENT_LIBS)
+libsrx_util_la_LDFLAGS =# $(GRPC_CLIENT_LDFLAG)
+
+# srx grpc library
+lib_LTLIBRARIES = libgrpc_service.la libgrpc_client_service.la
+libgrpc_service_la_SOURCES = $(SERVER_DIR)/grpc_service.c 
+#libgrpc_service_la_LIBADD = 
+#libgrpc_service_la_LDFLAGS = 
 
+libgrpc_client_service_la_SOURCES = $(CLIENT_DIR)/grpc_client_service.c 
+endif	
 ################################################################################
 ##  SRX - PROXY - API INSTALL
 ################################################################################
@@ -68,8 +109,15 @@ libSRxProxy_la_SOURCES = $(CLIENT_DIR)/c
 		    $(CLIENT_DIR)/srx_api.c
 
 # General linker flags
+if ENABLE_GRPC_COND
+libSRxProxy_la_LIBADD = libsrx_shared.la libsrx_util.la $(GRPC_CLIENT_LIBS)
+libSRxProxy_la_LDFLAGS = -version-info $(LIB_VER) $(GRPC_CLIENT_LDFLAG) $(GRPC_CLIENT_RPATH)
+
+else 
 libSRxProxy_la_LIBADD = libsrx_shared.la libsrx_util.la
 libSRxProxy_la_LDFLAGS = -version-info $(LIB_VER)
+endif	
+
 libSRxProxy_libconfigdir = $(sysconfdir)/ld.so.conf.d
 dist_libSRxProxy_libconfig_DATA = $(CLIENT_DIR)/srxproxy$(CPU_ARCH).conf
 
@@ -113,10 +161,26 @@ srx_server_SOURCES = $(SERVER_DIR)/bgpse
 		     $(SERVER_DIR)/aspa_trie.c \
 		     $(SERVER_DIR)/aspath_cache.c 
 
+if ENABLE_GRPC_COND
+srx_server_LDADD = $(LIB_PATRICIA) $(SCA_LIBS) \
+		   libsrx_shared.la \
+		   libsrx_util.la \
+		   libgrpc_service.la \
+		   $(GRPC_SERVER_LIBS)
+
+srx_server_LDFLAGS = $(SCA_LDFLAGS) \
+					 $(GRPC_SERVER_LDFLAG) \
+					 $(GRPC_SERVER_RPATH) \
+					 $(GRPC_CLIENT_LDFLAG) \
+					 $(GRPC_CLIENT_RPATH)
+else 
 srx_server_LDADD = $(LIB_PATRICIA) $(SCA_LIBS) \
 		   libsrx_shared.la \
 		   libsrx_util.la
 srx_server_LDFLAGS = $(SCA_LDFLAGS)
+endif
+
+
 
 ################################################################################
 ##  END SRX SERVER INSTALL
@@ -134,16 +198,26 @@ rpkirtr_client_SOURCES = $(TOOLS_DIR)/rp
                          $(SERVER_DIR)/rpki_packet_printer.c \
 		         $(SERVER_DIR)/rpki_router_client.c
 rpkirtr_client_LDADD   = libsrx_util.la
+if ENABLE_GRPC_COND
+rpkirtr_client_LDFLAGS = $(GRPC_CLIENT_LDFLAG) $(GRPC_CLIENT_RPATH)
+endif
 
 # Will be bundled with srx
 rpkirtr_svr_SOURCES = $(TOOLS_DIR)/rpkirtr_svr.c \
                       $(SERVER_DIR)/rpki_packet_printer.h
 rpkirtr_svr_LDADD   = libsrx_util.la
+if ENABLE_GRPC_COND
+rpkirtr_svr_LDFLAGS = $(GRPC_CLIENT_LDFLAG) $(GRPC_CLIENT_RPATH)
+endif
 
 # Will be bundled with srx-proxy
 srxsvr_client_SOURCES = $(TOOLS_DIR)/srxsvr_client.c 
+if ENABLE_GRPC_COND
+srxsvr_client_LDADD   = libsrx_util.la libsrx_shared.la libSRxProxy.la $(GRPC_CLIENT_LIBS) 
+srxsvr_client_LDFLAGS = $(GRPC_CLIENT_LDFLAG) $(GRPC_CLIENT_RPATH)
+else
 srxsvr_client_LDADD   = libsrx_util.la libsrx_shared.la libSRxProxy.la
-
+endif
 
 ################################################################################
 ##  END SRX TOOLS
--- ./client/client_connection_handler.c	2021-11-23 14:56:24.709374713 -0500
+++ ./client/client_connection_handler.c	2021-11-22 21:25:23.366963516 -0500
@@ -567,7 +567,7 @@ bool sendGoodbye(ClientConnectionHandler
   SRXPROXY_GOODBYE* hdr = (SRXPROXY_GOODBYE*)pdu;
   memset(pdu, 0, length);
 
-  LOG(LEVEL_DEBUG, HDR" send Goodbye! called" );
+  LOG(LEVEL_DEBUG, HDR" send Goodbye! called", pthread_self());
   hdr->type       = PDU_SRXPROXY_GOODBYE;
   hdr->keepWindow = htons(keepWindow);
   hdr->length     = htonl(length);
@@ -584,6 +584,153 @@ bool sendGoodbye(ClientConnectionHandler
   return false;
 }
 
+#ifdef USE_GRPC
+#include "client/libsrx_grpc_client.h"
+bool sendGoodbye_grpc(ClientConnectionHandler* self, uint16_t keepWindow)
+{
+  uint32_t length = sizeof(SRXPROXY_GOODBYE);
+  uint8_t pdu[length];
+  SRXPROXY_GOODBYE* hdr = (SRXPROXY_GOODBYE*)pdu;
+  memset(pdu, 0, length);
+
+  hdr->type       = PDU_SRXPROXY_GOODBYE;
+  hdr->keepWindow = htons(keepWindow);
+  hdr->length     = htonl(length);
+
+  LOG(LEVEL_INFO, HDR"+ send Goodbye! called", pthread_self());
+  LOG(LEVEL_INFO, HDR"+ [%s] :%d \n", pthread_self(), __FUNCTION__, __LINE__);
+
+  RunProxyGoodBye(*hdr, self->grpcClientID);
+  self->established = false;
+
+  return true;
+}
+
+typedef struct {
+    SRxProxy* proxy;
+    uint32_t proxyID;
+} StreamThreadData;
+
+// Imple GoStreamThread called for thread process
+//
+static void* GoodByeStreamThread(void *arg)
+{
+    StreamThreadData *std = (StreamThreadData*)arg;
+  
+    LOG(LEVEL_INFO, HDR "Run Proxy Good Bye Stream", pthread_self());
+    printf("Run Proxy Good Bye Stream \n");
+    printf("[%s:%d] arguments proxy: %p, proxyID: %08x\n", __FUNCTION__, __LINE__, std->proxy, std->proxyID);
+
+    while(!std->proxy->grpcClientEnable)
+    {
+        sleep(1);
+    }
+
+    // This is dummy data for initiating stream operation to use grpc tranortation
+    char buff_goodbye_stream_request[12] = {0x02, 0x03, 0x84, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0c};
+    /* 
+      typedef struct {                           
+        uint8_t   type;              // 2        
+        uint16_t  keepWindow;                    
+        uint8_t   reserved8;                     
+        uint32_t  zero32;                        
+        uint32_t  length;            // 12 Bytes 
+      } __attribute__((packed)) SRXPROXY_GOODBYE;
+    */
+
+    GoSlice goodbye_stream_pdu = {(void*)buff_goodbye_stream_request, (GoInt)12, (GoInt)12};
+    int result = RunProxyGoodByeStream (goodbye_stream_pdu, std->proxyID);
+
+    printf("Run Proxy Good Bye Stream terminated with result value: %d\n", result);
+    
+
+    // XXX: here general closure procedures by receiving GoodBye
+    //  relase proxy function is blocked, because reconnect function needs to have the proxy pointer,
+    //  so it should not be removed inside release SRxProxy ()
+    //
+    //releaseSRxProxy(std->proxy);
+}
+
+// This function for Proxy SyncRequest, Sign Notification and so on
+//
+static void* StreamThread(void *arg)
+{
+    StreamThreadData *std = (StreamThreadData*)arg;
+    printf("Run Proxy Stream \n");
+    printf("[%s:%d] arguments proxy: %p, proxyID: %08x\n", __FUNCTION__, __LINE__, std->proxy, std->proxyID);
+
+    //while(!std->proxy->grpcClientEnable)
+    {
+     //   sleep(1);
+    }
+
+    // This is dummy data for initiating stream operation to use grpc tranortation
+    char buff_stream_request[12] = {0x02, 0x00, 0x00, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0c};
+    GoSlice stream_pdu = {(void*)buff_stream_request, (GoInt)12, (GoInt)12};
+    int result = RunProxyStream (stream_pdu, std->proxyID);
+
+    printf("Run Proxy Stream terminated \n");
+
+}
+
+static void* WorkerPoolThread(void *arg)
+{
+
+    //bool ret = InitWorkerPool();
+}
+
+void ImpleGoStreamThread (SRxProxy* proxy, uint32_t proxyID)
+{
+    pthread_t tid, tid2, tid3;
+    pthread_attr_t attr, attr2, attr3;
+    pthread_attr_init(&attr);
+    pthread_attr_init(&attr2);
+    pthread_attr_init(&attr3);
+    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
+    pthread_attr_setdetachstate(&attr2, PTHREAD_CREATE_DETACHED);
+    pthread_attr_setdetachstate(&attr3, PTHREAD_CREATE_DETACHED);
+    printf("+ pthread grpc service started...\n");
+
+
+    StreamThreadData *std = (StreamThreadData*)malloc(sizeof(StreamThreadData));
+    std->proxy = proxy;
+    std->proxyID = proxyID;
+    printf("[%s:%d] arguments proxy: %p, proxyID: %08x\n", __FUNCTION__, __LINE__, std->proxy, std->proxyID);
+
+    int ret = pthread_create(&tid, &attr, GoodByeStreamThread, (void*)std);
+    if (ret != 0)
+    {
+        RAISE_ERROR("Failed to create a grpc thread");
+    }
+    printf("+ GoodBye Stream Thread created \n");
+    pthread_join(tid, NULL);
+
+
+
+    int ret2 = pthread_create(&tid2, &attr2, StreamThread, (void*)std);
+    if (ret2 != 0)
+    {
+        RAISE_ERROR("Failed to create a grpc thread");
+    }
+    printf("+ Stream Thread for notification created \n");
+    pthread_join(tid2, NULL);
+
+
+    /*
+    int ret3 = pthread_create(&tid3, &attr3, WorkerPoolThread, (void*)NULL);
+    if (ret3 != 0)
+    {
+        RAISE_ERROR("Failed to create a grpc workerPoll thread");
+    }
+    printf("+ Worker Pool Thread created \n");
+    pthread_join(tid3, NULL);
+    */
+    
+    printf("+ All Go Stream Threads Terminated \n");
+}
+
+
+#endif // USE_GRPC
 ////////////////////////////////////////////////////////////////////////////////
 // Local helper functions
 ////////////////////////////////////////////////////////////////////////////////
@@ -607,7 +754,7 @@ bool reconnectSRX(ClientConnectionHandle
   bool retVal = false;
   SRxProxy* proxy = (SRxProxy*)self->srxProxy;
 
-  LOG (LEVEL_DEBUG, "([0x%08X]) > Client Connection Handler Thread started!",
+  LOG (LEVEL_INFO, "([0x%08X]) > Client Connection Handler Thread started!",
                      pthread_self());
   
   if (self->initialized && !self->stop)
--- ./client/client_connection_handler.h	2021-11-23 14:56:24.709374713 -0500
+++ ./client/client_connection_handler.h	2021-11-22 21:25:23.366963516 -0500
@@ -102,6 +102,9 @@ typedef struct {
   SRxProxy*        srxProxy;      // A pointer to the SRX proxy instance.
                                   // Will be set using the method
                                   // initializeClientConnectionHandler.
+#ifdef USE_GRPC
+  unsigned int    grpcClientID;
+#endif
 } ClientConnectionHandler;
 
 /**
--- ./client/grpc_client_service.c	1969-12-31 19:00:00.000000000 -0500
+++ ./client/grpc_client_service.c	2021-11-22 21:25:23.366963516 -0500
@@ -0,0 +1,249 @@
+
+#include <stdio.h>
+#include "client/grpc_client_service.h"
+#include "client/client_connection_handler.h"
+#define HDR  "(GRPC_Client_ServiceHandler): "
+
+
+static void dispatchPackets_grpc(SRXPROXY_BasicHeader* packet, void* proxyPtr);
+
+extern SRxProxy* g_proxy;
+
+
+__attribute__((always_inline)) inline void printHex(int len, unsigned char* buff)
+{
+  int i;
+  for(i=0; i < len; i++ )
+  {
+      if(i%16 ==0) printf("\n");
+      printf("%02x ", buff[i]);
+  }
+  printf("\n");
+}
+
+
+
+void processVerifyNotify_grpc(SRXPROXY_VERIFY_NOTIFICATION* hdr)
+{
+    //LOG(LEVEL_DEBUG, HDR "+++ [%s] called in proxy: %p \n", __FUNCTION__, g_proxy);
+    SRxProxy* proxy = g_proxy;
+
+    //printHex(sizeof(SRXPROXY_VERIFY_NOTIFICATION), (unsigned char*)hdr);
+
+    if (proxy)
+    {
+        if (proxy->resCallback != NULL)
+        {
+            bool hasReceipt = (hdr->resultType & SRX_FLAG_REQUEST_RECEIPT)
+                == SRX_FLAG_REQUEST_RECEIPT;
+            bool useROA     = (hdr->resultType & SRX_FLAG_ROA) == SRX_FLAG_ROA;
+            bool useBGPSEC  = (hdr->resultType & SRX_FLAG_BGPSEC) == SRX_FLAG_BGPSEC;
+            bool useASPA    = (hdr->resultType & SRX_FLAG_ASPA) == SRX_FLAG_ASPA;
+
+            uint32_t localID = ntohl(hdr->requestToken);
+            SRxUpdateID updateID = ntohl(hdr->updateID);
+
+#ifdef BZ263
+            ct++;
+            //LOG(LEVEL_DEBUG, HDR "#%u - uid:0x%08x lid:0x%08X (%u)\n", ct, updateID, localID,
+            //        localID);
+#endif
+
+            if (localID > 0 && !hasReceipt)
+            {
+                LOG(LEVEL_DEBUG, HDR " -> ERROR, no receipt flag set.\n");
+                LOG(LEVEL_WARNING, HDR "Unusual notification for update [0x%08X] with "
+                        "local id [0x%08X] but receipt flag NOT SET!",
+                        updateID, localID);
+                localID = 0;
+            }
+            else
+            {
+                //LOG(LEVEL_DEBUG, HDR "Update [0x%08X] with localID [0x%08X]: %d",
+                //        updateID, localID, localID);
+            }
+
+            uint8_t roaResult    = useROA ? hdr->roaResult : SRx_RESULT_UNDEFINED;
+            uint8_t bgpsecResult = useBGPSEC ? hdr->bgpsecResult : SRx_RESULT_UNDEFINED;
+            uint8_t aspaResult   = useASPA ? hdr->aspaResult : SRx_RESULT_UNDEFINED;
+            ValidationResultType valType = hdr->resultType & SRX_FLAG_ROA_BGPSEC_ASPA;
+
+            // hasReceipt ? localID : 0 is result of BZ263  // in qsrx, calls handleSRxValidationResult()
+            proxy->resCallback(updateID, localID, valType, roaResult, bgpsecResult,
+                       aspaResult, proxy->userPtr); // call handleSRxValidationResult
+        }
+        else
+        {
+            LOG(LEVEL_INFO, "processVerifyNotify: NO IMPLEMENTATION PROVIDED FOR "
+                    "proxy->resCallback!!!\n");
+        }
+    }
+    else
+    {
+        LOG(LEVEL_WARNING, HDR "this client doens't have a proxy pointer set, maybe due to simple test\n");
+    }
+}
+
+void processGoodbye_grpc(SRXPROXY_GOODBYE* hdr)
+{
+    LOG(LEVEL_INFO, HDR "+++ [%s] called in proxy: %p ", __FUNCTION__, g_proxy);
+    SRxProxy* proxy = g_proxy;
+
+  
+    LOG(LEVEL_INFO, HDR "Release SRx Proxy flags and Connection Handler's flags");
+    if (proxy)
+    {
+        // The client connection handler
+        ClientConnectionHandler* connHandler =
+            (ClientConnectionHandler*)proxy->connHandler;
+        LOG(LEVEL_DEBUG, HDR "Received Goodbye", pthread_self());
+        // SERVER CLOSES THE CONNECTION. END EVERYTHING.
+        connHandler->established = false;
+        connHandler->stop = true;
+
+        proxy->grpcClientEnable = false;  
+        proxy->grpcConnectionInit = false;
+
+        //releaseClientConnectionHandler(connHandler);
+
+        // It is possible to receive a Goodbye during handshake in this case the 
+        // connection handler is NOT initialized yet. The main process is still in 
+        // init process and the init process has to cleanup.
+        if (connHandler->initialized)
+        {
+            // Do not receive or try to connect anymore
+            connHandler->stop = true;
+
+            // Make sure the SIGINT does not terminate the program
+            signal(SIGINT, SIG_IGN); // Ignore the signals
+
+
+            // Reinstall the default signal handler
+            signal(SIGINT, SIG_DFL);
+
+            // Deallocate the send queue and lock
+            acquireWriteLock(&connHandler->queueLock);
+            releaseSList(&connHandler->sendQueue);
+            releaseRWLock(&connHandler->queueLock);
+
+            // Deallocate The packet receive monitor
+            if (connHandler->rcvMonitor != NULL)
+            {
+                pthread_mutex_destroy(connHandler->rcvMonitor);
+                free(connHandler->rcvMonitor);
+                connHandler->rcvMonitor = NULL;
+            }
+
+            if (connHandler->cond != NULL)
+            {
+                pthread_cond_destroy(connHandler->cond);
+                free(connHandler->cond);
+                connHandler->cond       = NULL;
+            }
+        }
+    }
+    else
+    {
+        LOG(LEVEL_WARNING, HDR "this client doens't have a proxy pointer set, maybe due to simple test\n");
+    }
+
+}
+
+void processSyncRequest_grpc(SRXPROXY_SYNCH_REQUEST* hdr)
+{
+    LOG(LEVEL_INFO, HDR "++ [%s] called in proxy: %p \n", __FUNCTION__, g_proxy);
+    SRxProxy* proxy = g_proxy;
+
+    if (proxy)
+    {
+        if (proxy->syncNotification != NULL)
+        {
+            proxy->syncNotification(proxy->userPtr);  // call --> handleSRxSynchRequest()
+        }
+        else
+        {
+            LOG(LEVEL_INFO, "processSyncRequest: NO IMPLEMENTATION PROVIDED FOR "
+                    "proxy->syncNotification!!!\n");
+        }
+    }
+    else{
+
+        LOG(LEVEL_WARNING, HDR "this client doens't have a proxy pointer set, maybe due to simple test\n");
+    }
+}
+
+void processSignNotify_grpc(SRXPROXY_SIGNATURE_NOTIFICATION* hdr)
+{
+    LOG(LEVEL_DEBUG, HDR "+++ [%s] called in proxy: %p \n", __FUNCTION__, g_proxy);
+    SRxProxy* proxy = g_proxy;
+    
+    if (proxy)
+    {
+        // @TODO: Finishe the implementation with the correct data.
+        if (proxy->sigCallback != NULL)
+        {
+            LOG(LEVEL_INFO, "processSignNotify: NOT IMPLEMENTED IN THIS PROTOTYPE!!!\n");
+            SRxUpdateID updId = hdr->updateIdentifier;
+            //TODO finish processSigNotify - especially the bgpsec data
+            BGPSecCallbackData bgpsecCallback;
+            bgpsecCallback.length = 0;
+            bgpsecCallback.data = NULL;
+            proxy->sigCallback(updId, &bgpsecCallback, proxy->userPtr);
+        }
+        else
+        {
+            LOG(LEVEL_INFO, "processSignNotify: NO IMPLEMENTATION PROVIDED FOR "
+                    "proxy->sigCallback!!!\n");
+        }
+    }
+}
+
+
+
+
+extern void callCMgmtHandler(SRxProxy* proxy, SRxProxyCommCode mainCode, int subCode);
+
+void processError_grpc(SRXPROXY_ERROR* hdr)
+{
+  LOG(LEVEL_INFO, HDR "+++ [%s] called in proxy: %p ", __FUNCTION__, g_proxy);
+  SRxProxy* proxy = g_proxy;
+
+  uint32_t errCode = ntohs(hdr->errorCode);
+  switch (errCode)
+  {
+    case SRXERR_WRONG_VERSION:
+      LOG(LEVEL_ERROR, "SRx server reports compatibility issues in the "
+          "communication protocol!");
+      callCMgmtHandler(proxy, COM_ERR_PROXY_COMPATIBILITY,
+          COM_PROXY_NO_SUBCODE);
+      break;
+    case SRXERR_DUPLICATE_PROXY_ID:
+      LOG(LEVEL_ERROR, "SRx server reports a conflict with the proxy id!");
+      callCMgmtHandler(proxy, COM_ERR_PROXY_DUPLICATE_PROXY_ID,
+          COM_PROXY_NO_SUBCODE);
+      break;
+    case SRXERR_INVALID_PACKET:
+      LOG(LEVEL_ERROR, "SRx server received an invalid packet!");
+      callCMgmtHandler(proxy, COM_ERR_PROXY_SERVER_ERROR, SVRINVPKG);
+      break;
+    case SRXERR_INTERNAL_ERROR:
+      LOG(LEVEL_ERROR, "SRx server reports an internal error!");
+      callCMgmtHandler(proxy, COM_ERR_PROXY_SERVER_ERROR, SVRINTRNL);
+      break;
+    case SRXERR_ALGO_NOT_SUPPORTED:
+      LOG(LEVEL_ERROR, "SRx server reports the requested signature algorithm "
+          "is not supported!");
+      callCMgmtHandler(proxy, COM_ERR_PROXY_UNKNOWN_ALGORITHM,
+          COM_PROXY_NO_SUBCODE);
+      break;
+    case SRXERR_UPDATE_NOT_FOUND:
+      LOG(LEVEL_NOTICE, "SRx server reports the last delete/signature request "
+          "was aborted, the update could not be found!");
+      callCMgmtHandler(proxy, COM_ERR_PROXY_UNKNOWN_UPDATE,
+          COM_PROXY_NO_SUBCODE);
+      break;
+    default:
+      RAISE_ERROR("SRx server reports an unknown Error(%u)!", errCode);
+      callCMgmtHandler(proxy, COM_ERR_PROXY_UNKNOWN, errCode);
+  }
+}
--- ./client/grpc_client_service.h	1969-12-31 19:00:00.000000000 -0500
+++ ./client/grpc_client_service.h	2021-11-22 21:25:23.366963516 -0500
@@ -0,0 +1,23 @@
+#ifndef GRPC_CLIENT_SERVICE_H
+#define GRPC_CLIENT_SERVICE_H
+
+#include "client/srx_api.h"
+#include "shared/srx_packets.h"
+#include "util/log.h"
+
+
+typedef struct {
+    unsigned int size;
+    unsigned char *data;
+    unsigned char info;
+} RET_DATA;
+
+SRxProxy* g_proxy;
+
+void processVerifyNotify_grpc(SRXPROXY_VERIFY_NOTIFICATION* hdr);
+void processGoodbye_grpc(SRXPROXY_GOODBYE* hdr);
+void processSyncRequest_grpc(SRXPROXY_SYNCH_REQUEST* hdr);
+void processSignNotify_grpc(SRXPROXY_SIGNATURE_NOTIFICATION* hdr);
+void processError_grpc(SRXPROXY_ERROR* hdr);
+
+#endif
--- ./client/srx_api.c	2021-11-23 14:56:24.709374713 -0500
+++ ./client/srx_api.c	2021-11-22 21:25:23.367963522 -0500
@@ -90,6 +90,11 @@
 #include "util/mutex.h"
 #include "util/log.h"
 #include "util/socket.h"
+#ifdef USE_GRPC
+#include "client/grpc_client_service.h"
+#include "client/libsrx_grpc_client.h"
+extern bool sendGoodbye_grpc(ClientConnectionHandler* self, uint16_t keepWindow);
+#endif
 
 #define HDR "(SRX API): "
 
@@ -101,6 +106,7 @@ static ProxyLogger _pLogger = NULL;
 static void dispatchPackets(SRXPROXY_BasicHeader* packet, void* proxyPtr);
 void callCMgmtHandler(SRxProxy* proxy, SRxProxyCommCode mainCode, int subCode);
 void pLog(LogLevel level, const char* fmt, va_list args);
+inline void printHex(int len, unsigned char* buff);
 
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -184,8 +190,9 @@ SRxProxy* createSRxProxy(ValidationReady
   proxy->socketConfig.resetSendErrors = 1000;
   proxy->socketConfig.succsessSend = 0;
 
-  //setLogLevel(LEVEL_DEBUG);
-  setLogLevel(LEVEL_ERROR);
+  setLogLevel(LEVEL_DEBUG);
+  //setLogLevel(LEVEL_ERROR);
+  //setLogLevel(LEVEL_INFO);
 
   // By default the socket is controlled internally
   proxy->externalSocketControl = false;
@@ -193,6 +200,12 @@ SRxProxy* createSRxProxy(ValidationReady
   // initialize the connection handler
   proxy->connHandler = createClientConnectionHandler(proxy);
 
+#ifdef USE_GRPC
+  // grpc connections
+  proxy->grpcClientEnable = false;
+  proxy->grpcConnectionInit = false;
+#endif // USE_GRPC
+
   return proxy;
 }
 
@@ -205,6 +218,7 @@ void releaseSRxProxy(SRxProxy* proxy)
 {
   if (proxy != NULL)
   {
+    LOG(LEVEL_DEBUG, "### [%s] ###  Reset process ... ", __FUNCTION__);
     disconnectFromSRx(proxy, SRX_DEFAULT_KEEP_WINDOW);
     releaseSList(&proxy->peerAS);
     free(proxy->connHandler);
@@ -340,7 +354,14 @@ void deleteUpdate(SRxProxy* proxy, uint1
     hdr->length           = htonl(length);
     hdr->updateIdentifier = htonl(updateID);
 
+#ifdef USE_GRPC
+  GoSlice verify_pdu = {(void*)hdr, (GoInt)length, (GoInt)length};
+  printHex(length, (unsigned char*)hdr);
+  int32_t result = ImpleProxyDeleteUpdate(verify_pdu, connHandler->grpcClientID);
+  LOG(LEVEL_INFO, HDR "[deleteUpdate] Result: %02x\n", result);
+#else
     sendData(&connHandler->clSock, hdr, length);
+#endif
 
     free(hdr);
   }
@@ -507,6 +528,21 @@ bool disconnectFromSRx(SRxProxy* proxy,
   // Macro for type casting back to the proxy.
   if (isConnected(proxy))
   {
+#ifdef USE_GRPC
+    if(proxy->grpcClientEnable && connHandler->grpcClientID)
+      {
+        LOG(LEVEL_INFO, "### [%s] ###  Reset process ... ", __FUNCTION__);
+        sendGoodbye_grpc(connHandler, keepWindow);
+        connHandler->grpcClientID = 0;
+        proxy->grpcClientEnable = false;
+        proxy->grpcConnectionInit = false;
+
+      }
+      else
+        sendGoodbye(connHandler, keepWindow);
+#else
+      sendGoodbye(connHandler, keepWindow);
+#endif
     sendGoodbye(connHandler, keepWindow);
     connHandler->established = false;
     releaseClientConnectionHandler(connHandler);
@@ -1086,13 +1122,13 @@ void processVerifyNotify(SRXPROXY_VERIFY
 
 #ifdef BZ263
     ct++;
-    printf("#%u - uid:0x%08x lid:0x%08X (%u)\n", ct, updateID, localID,
-           localID);
+    //LOG(LEVEL_DEBUG, HDR "#%u - uid:0x%08x lid:0x%08X (%u)\n", 
+    //ct, updateID, localID, localID);
 #endif
 
     if (localID > 0 && !hasReceipt)
     {
-      printf(" -> ERROR, no receipt flag set.\n");
+      LOG(LEVEL_WARNING, HDR " -> ERROR, no receipt flag set.\n");
       LOG(LEVEL_WARNING, HDR "Unusual notification for update [0x%08X] with "
                          "local id [0x%08X] but receipt flag NOT SET!",
           updateID, localID);
@@ -1382,3 +1418,180 @@ bool isErrorCode(SRxProxyCommCode code)
   // Error codes are between 0..127
   return (code & 0x7F) == code;
 }
+
+#ifdef USE_GRPC
+bool connectToSRx_grpc(SRxProxy* proxy, const char* host, int port,
+                  int handshakeTimeout, bool externalSocketControl)
+{
+
+  LOG(LEVEL_INFO, "[SRx Client] Establish connection with proxyID [0x%x]...", proxy->proxyID);
+  uint32_t noPeers    = 0; //proxy->peerAS.size;
+  uint32_t length     = sizeof(SRXPROXY_HELLO) + (noPeers * 4);
+  uint8_t  pdu[length];
+  SRXPROXY_HELLO* hdr = (SRXPROXY_HELLO*)pdu;
+  uint32_t peerASN    = 0;
+  uint32_t* peerAS    = NULL;
+  printf("[SRx Client] ========= proxy hello size: %d leng: %d ====== \n", sizeof(SRXPROXY_HELLO), length );
+
+  memset(pdu, 0, length);
+
+  hdr->type            = PDU_SRXPROXY_HELLO;
+  hdr->version         = htons(SRX_PROTOCOL_VER);
+  hdr->length          = htonl(length);
+  hdr->proxyIdentifier = htonl(proxy->proxyID);
+  hdr->asn             = htonl(proxy->proxyAS);
+  hdr->noPeers         = htonl(noPeers);
+
+  LOG(LEVEL_INFO, HDR "[SRx Client] Request Proxy Hello:");
+
+  LogLevel lv = getLogLevel();
+  LOG(LEVEL_NOTICE, HDR "[SRx Client] srx client log Level : %d (set from createSRxProxy)\n", lv);
+  if (lv >= LEVEL_NOTICE) {
+    printHex(length, pdu);
+  }
+    
+  unsigned char result[sizeof(SRXPROXY_HELLO_RESPONSE)];
+  //unsigned char result[12];
+
+  int size = length;
+  char buf_data[size];
+  memcpy(buf_data, pdu, size);
+
+  GoSlice gopdu = {(void*)buf_data, (GoInt)size, (GoInt)size};
+  //result = Run(gopdu);
+  //printf(" ---- sleep 5 sec delaying hello request \n");
+  //sleep(5);
+  struct RunProxyHello_return tResp = RunProxyHello(gopdu);
+  unsigned char* pRes = tResp.r0;
+  memcpy(result, pRes, sizeof(SRXPROXY_HELLO_RESPONSE));
+
+  printf("------- [SRx Client](srx_api.c :: connectToSRx grpc) hello response ----------\n");
+  LOG(LEVEL_NOTICE, HDR "[SRx Client] Response Proxy[ID:%d] Hello Response: ", tResp.r1);
+  if (lv >= LEVEL_NOTICE) {
+    printHex(sizeof(SRXPROXY_HELLO_RESPONSE), result);
+  }
+
+  ClientConnectionHandler* connHandler =
+                                   (ClientConnectionHandler*)proxy->connHandler;
+
+  connHandler->packetHandler = dispatchPackets;
+  connHandler->stop = false;
+  connHandler->handshake_timeout = SRX_DEFAULT_HANDSHAKE_TIMEOUT;
+  connHandler->initialized = true;
+  connHandler->established = false;
+      
+  // XXX NOTE: packet Handler set a flag,'established' with true or false
+  connHandler->packetHandler((SRXPROXY_BasicHeader*)result, proxy); // --> dispatchPackets()
+
+  free(pRes);
+  
+  if (connHandler->established)
+  {
+      connHandler->grpcClientID = ntohl(((SRXPROXY_HELLO_RESPONSE*)result)->proxyIdentifier);
+      proxy->grpcClientEnable = true;
+      LOG(LEVEL_NOTICE, HDR "[SRx Client] grpc client id: %08x\n", connHandler->grpcClientID);
+  }
+
+  // following return value will be determined by calling (fn_packetHandler --> fn_dispatchPackets)
+  return connHandler->established;
+}
+/*
+//int responseGRPC (int size)
+void responseGRPC(void)
+{
+    printf("[%s] calling - size:  \n", __FUNCTION__);
+    //printf("[%s] calling - size: %d \n", __FUNCTION__, size);
+
+    //return 0;
+}
+
+*/
+
+void verifyUpdate_grpc(SRxProxy* proxy, uint32_t localID,
+                  bool usePrefixOriginVal, bool usePathVal, bool useAspaVal,
+                  SRxDefaultResult* defaultResult,
+                  IPPrefix* prefix, uint32_t as32,
+                  BGPSecData* bgpsec, SRxASPathList asPathList)
+{
+  LOG(LEVEL_NOTICE, "[SRx Client] calling verify Update grpc  [proxyID:0x%x]...", proxy->proxyID);
+  if (!isConnected(proxy))
+  {
+    RAISE_ERROR(HDR "Abort verify, not connected to SRx server!" ,
+                pthread_self());
+    return;
+  }
+
+  // Specify the verify request method.
+  uint8_t method =   (usePrefixOriginVal ? SRX_FLAG_ROA : 0)
+                   | (usePathVal ? SRX_FLAG_BGPSEC : 0)
+                   | (useAspaVal ? SRX_FLAG_ASPA : 0)
+                   | (localID != 0 ? SRX_FLAG_REQUEST_RECEIPT : 0);
+
+  bool isV4 = prefix->ip.version == 4;
+  // The client connection handler
+  ClientConnectionHandler* connHandler =
+                                   (ClientConnectionHandler*)proxy->connHandler;
+
+  // create data packet.
+  uint16_t bgpsecLength = 0;
+  if (bgpsec != NULL)
+  {
+    bgpsecLength = (bgpsec->numberHops * 4) + bgpsec->attr_length;
+  }
+  uint32_t length = (isV4 ? sizeof(SRXPROXY_VERIFY_V4_REQUEST)
+                          : sizeof(SRXPROXY_VERIFY_V6_REQUEST)) + bgpsecLength;
+  uint8_t  pdu[length];
+  uint32_t requestToken = localID;
+
+  memset(pdu, 0, length);
+
+  // Generate VERIFY PACKET
+  if (isV4)
+  {
+    createV4Request(pdu, method, requestToken, defaultResult, prefix, as32, bgpsec, asPathList);
+  }
+  else
+  {
+    createV6Request(pdu, method, requestToken, defaultResult, prefix, as32, bgpsec);
+  }
+
+  // Send Data
+  //sendPacketToServer(connHandler, (SRXPROXY_PDU*)pdu, length);
+
+  GoSlice verify_pdu = {(void*)pdu, (GoInt)length, (GoInt)length};
+  //int32_t result = RunStream(verify_pdu);
+  printf("============== Run ProxyVerify calling (From Client ProxyAPI)  ===============\n");
+  printf("---- PDU (from create V4 request) --: \n");
+  printHex(length, pdu);
+  int32_t result = RunProxyVerify(verify_pdu, connHandler->grpcClientID);
+  LOG(LEVEL_NOTICE, HDR "[SRx Client] Validation Result: %02x\n", result);
+
+}
+
+bool callSRxGRPC_Init(const char* addr)
+{
+    GoString gs_addr = {
+        p : addr, // "localhost:50000",
+        n : 0
+    };
+    gs_addr.n = strlen((const char*)addr);
+
+    bool res = InitSRxGrpc(gs_addr); // res:0 failure to connect, res:1 success to connect
+    LOG(LEVEL_NOTICE, HDR  "Init SRx GRPC result: %d (0: fail, 1:sucess) \n", res);
+
+    return res;
+}
+
+
+#endif /* USE GRPC */
+
+__attribute__((always_inline)) inline void printHex(int len, unsigned char* buff)
+{
+    int i;
+    for(i=0; i < len; i++ )
+    {
+        if(i%16 ==0) printf("\n");
+        printf("%02x ", buff[i]);
+    }
+    printf("\n");
+}
--- ./client/srx_api.h	2021-11-23 14:56:24.709374713 -0500
+++ ./client/srx_api.h	2021-11-22 21:25:23.367963522 -0500
@@ -74,6 +74,9 @@
 #include "shared/srx_defs.h"
 #include "util/prefix.h"
 #include "util/slist.h"
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif /* HAVE_CONFIG_H */
   
 
 /** This type specifies the different error codes the proxy provides. */
@@ -283,6 +286,10 @@ typedef struct {
     
   // Experimental
   ProxySocketConfig socketConfig;
+#ifdef USE_GRPC 
+  bool  grpcClientEnable; 
+  bool  grpcConnectionInit; 
+#endif
 } SRxProxy;
 
 
--- ./configure.ac	2021-11-23 14:56:24.711374725 -0500
+++ ./configure.ac	2021-11-22 21:25:23.368963528 -0500
@@ -265,6 +265,26 @@ AC_ARG_WITH([buildtest],
 AC_MSG_RESULT([${withval}])
 AM_CONDITIONAL([BUILD_TEST], [test x$buildtest = xtrue])
 
+# check gRPC support variables
+AC_ARG_ENABLE(grpc,
+              [ --enable-grpc       enable grpc features],
+              [enable_grpc="yes"],[])
+
+AM_CONDITIONAL([ENABLE_GRPC_COND], [test x$enable_grpc = xyes])
+
+AC_MSG_CHECKING(checking to see if grpc is enabled)
+if test "x${enable_grpc}" = "xyes"; then
+    AC_MSG_RESULT(yes)
+    AC_DEFINE([USE_GRPC],[], SRX GRPC)
+    AC_ARG_VAR(grpc_dir, provide grpc driver directory in which grpc server and client installed)
+else
+    AC_MSG_RESULT(no) 
+fi
+
+
+
+
+
 AS_BOX(Processing required headers)
 # Checks for header files.
 #                  winsock.h \
--- ./server/aspa_trie.c	2021-11-23 14:56:24.713374736 -0500
+++ ./server/aspa_trie.c	2021-11-22 21:25:23.372963551 -0500
@@ -42,6 +42,13 @@
 #include "util/log.h"
 
 static uint32_t countTrieNode =0;
+
+static TrieNode* newAspaTrie(void);
+static TrieNode* make_trienode(char data, char* userData, ASPA_Object* );
+static void free_trienode(TrieNode* node);
+static int search_trie(TrieNode* root, char* word);
+static void emptyAspaDB(ASPA_DBManager* self);
+
 int process_ASPA_EndOfData_main(void* uc, void* handler, uint32_t uid, uint32_t pid, time_t ct);
 extern RPKI_QUEUE* getRPKIQueue();
 extern uint8_t validateASPA (PATH_LIST* asPathList, uint8_t length, AS_TYPE asType, 
@@ -326,7 +333,7 @@ static int search_trie(TrieNode* root, c
 //
 ASPA_Object* findAspaObject(ASPA_DBManager* self, char* word)
 {
-    ASPA_Object *obj;
+    ASPA_Object *obj=NULL;
   
     acquireWriteLock(&self->tableLock);
     TrieNode* temp = self->tableRoot; 
@@ -425,12 +432,13 @@ void print_search(TrieNode* root, char*
 // 
 // external API for db loopkup
 //
+#define MAX_ASN_LENGTH 7
 ASPA_ValidationResult ASPA_DB_lookup(ASPA_DBManager* self, uint32_t customerAsn, 
                                      uint32_t providerAsn, uint8_t afi )
 {
   LOG(LEVEL_DEBUG, FILE_LINE_INFO " ASPA DB Lookup called");
 
-  char strCusAsn[6] = {};
+  char strCusAsn[MAX_ASN_LENGTH] = {};
   sprintf(strCusAsn, "%d", customerAsn);  
 
   ASPA_Object *obj = findAspaObject(self, strCusAsn);
@@ -493,8 +501,6 @@ int process_ASPA_EndOfData_main(void* uc
   }
   else
   {
-    if (defaultRes.result.aspaResult != SRx_RESULT_INVALID)
-    {
       ASPA_DBManager* aspaDBManager = rpkiHandler->aspaDBManager;
       TrieNode *root = aspaDBManager->tableRoot;
 
@@ -580,13 +586,6 @@ int process_ASPA_EndOfData_main(void* uc
       if (aspl)
         free (aspl);
 
-    } // end of if defaultRes result
-    else 
-    {
-      LOG(LEVEL_ERROR, "Update 0x%08X is not capable to do ASPA validation",
-          updateID);
-      return 0;
-    }
   }// end of else
 
 
--- ./server/aspa_trie.h	2021-11-23 14:56:24.713374736 -0500
+++ ./server/aspa_trie.h	2021-11-22 21:25:23.372963551 -0500
@@ -72,14 +72,9 @@ typedef struct {
 } ASPA_DBManager;
 
 
-static TrieNode* newAspaTrie(void);
-static TrieNode* make_trienode(char data, char* userData, ASPA_Object* );
-static void free_trienode(TrieNode* node);
 TrieNode* insertAspaObj(ASPA_DBManager* self, char* word, char* userData, ASPA_Object* obj);
-static int search_trie(TrieNode* root, char* word);
 void print_trie(TrieNode* root);
 bool initializeAspaDBManager(ASPA_DBManager* aspaDBManager, Configuration* config);
-static void emptyAspaDB(ASPA_DBManager* self);
 ASPA_Object* findAspaObject(ASPA_DBManager* self, char* word);
 void print_search(TrieNode* root, char* word);
 bool deleteASPAObject(ASPA_DBManager* self, ASPA_Object *obj);
--- ./server/command_handler.c	2021-11-23 14:56:24.713374736 -0500
+++ ./server/command_handler.c	2021-11-22 21:25:23.372963551 -0500
@@ -823,6 +823,14 @@ static bool _processUpdateValidation(Com
       deleteAspathListEntry (aspl);
   }
 
+  // Invalid case
+  else if (aspaVal && (srxRes.aspaResult == SRx_RESULT_UNDEFINED)
+      && (defRes.result.aspaResult == SRx_RESULT_INVALID)
+      && (defRes.resSourceASPA = SRxRS_ROUTER))
+  {
+    LOG(LEVEL_INFO, "default result from a router is invalid, so sening it as well");
+    srxRes_mod.aspaResult = SRx_RESULT_INVALID;
+  }
 
   //
   // in case, path id already exists in AS Path Cache and srx result already 
@@ -864,6 +872,12 @@ static bool _processUpdateValidation(Com
     }    
   }
   
+#ifdef USE_GRPC
+  // [grpc] close send stream from server
+  //if (cmdHandler->grpcEnable)
+      //cb_proxy(0, NULL);
+#endif
+  
   return processed;
 }
 
@@ -1013,11 +1027,19 @@ static void* handleCommands(void* arg)
               LOG(LEVEL_DEBUG, HDR "GoodBye!", pthread_self());
               break;
             case PDU_SRXPROXY_DELTE_UPDATE:
+              //_processDeleteUpdate_grpc(cmdHandler, item);
               _processDeleteUpdate(cmdHandler, item);
               break;
             case PDU_SRXPROXY_PEER_CHANGE:
               _processPeerChange(cmdHandler, item);
               break;
+#ifdef USE_GRPC
+            case PDU_SRXPROXY_SYNC_REQUEST:
+              LOG(LEVEL_INFO, HDR "[SRx server][handle_commands](Hello Resonse) "
+                  "calling cb_proxyStream in CommandHandler", pthread_self());
+              cb_proxyStream(item->dataLength, bhdr);
+              break;
+#endif // USE_GRPC
             default:
               RAISE_ERROR("Unknown/unsupported pdu type: %d",
                           item->dataID);
@@ -1113,6 +1135,11 @@ bool broadcastResult(CommandHandler* sel
 
     /* extract a specific client to send packet */
     retVal = false;
+#ifdef USE_GRPC
+    if (self->grpcEnable)
+        cb_proxy(pduLength, pdu);
+#endif
+
     while  (clientCt-- > 0)
     {
       // work the clients array backwards - saves maintaining a counter variable
--- ./server/command_handler.h	2021-11-23 14:56:24.714374742 -0500
+++ ./server/command_handler.h	2021-11-22 21:25:23.372963551 -0500
@@ -84,6 +84,9 @@ typedef struct {
   // Internal
   pthread_t                 threads[NUM_COMMAND_HANDLER_THREADS];
   int                       numThreads;
+#ifdef USE_GRPC
+  bool                      grpcEnable;
+#endif
 } CommandHandler;
 
 /**
@@ -141,6 +144,7 @@ void stopProcessingCommands(CommandHandl
  *              registered client
  */
 bool broadcastResult(CommandHandler* self, SRxValidationResult* valResult);
+bool _isSet(uint32_t bitmask, uint32_t bits);
 
 
 /**
--- ./server/configuration.c	2021-11-23 14:56:24.714374742 -0500
+++ ./server/configuration.c	2021-11-22 21:25:23.373963556 -0500
@@ -245,6 +245,10 @@ void initConfiguration(Configuration* se
   self->mode_no_sendqueue = false;
   self->mode_no_receivequeue = false;
 
+#ifdef USE_GRPC
+#define DEFAULT_GRPC_PORT 50000
+  self->grpc_port = DEFAULT_GRPC_PORT;
+#endif
   self->defaultKeepWindow = SRX_DEFAULT_KEEP_WINDOW; // from srx_defs.h
   memset(&self->mapping_routerID, 0, MAX_PROXY_MAPPINGS);
 }
@@ -772,6 +776,17 @@ bool readConfigFile(Configuration* self,
     goto free_config;
   }
 
+#ifdef USE_GRPC 
+  // grpc
+  sett = config_lookup(&cfg, "grpc");
+  if (sett != NULL)
+  {
+    if ( config_setting_lookup_int(sett, "port", &intVal) == CONFIG_TRUE )
+    { self->grpc_port = (int)intVal ; }
+  }
+#endif
+
+
   // optional experimental
   sett = config_lookup(&cfg, "mode");
   if (sett != NULL)
--- ./server/configuration.h	2021-11-23 14:56:24.714374742 -0500
+++ ./server/configuration.h	2021-11-22 21:25:23.373963556 -0500
@@ -51,6 +51,9 @@
 
 #include <stdbool.h>
 #include <stdint.h>
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif /* HAVE_CONFIG_H */
 
 //@TODO: Remove line below
 //static char* DEFAULT_CONSOLE_PASSWORD = "SRxSERVER";
@@ -131,6 +134,9 @@ typedef struct {
   int                   defaultKeepWindow;
   /** the configuration array for the proxy mapping */
   uint32_t              mapping_routerID[256];
+#ifdef USE_GRPC
+  uint32_t              grpc_port;
+#endif
 } Configuration;
 
 /**
--- ./server/grpc_service.c	1969-12-31 19:00:00.000000000 -0500
+++ ./server/grpc_service.c	2021-11-23 20:11:29.122901066 -0500
@@ -0,0 +1,787 @@
+
+
+#include <stdio.h>
+#include "server/grpc_service.h"
+#include "server/command_handler.h"
+
+#define HDR  "(GRPC_ServiceHandler): "
+static void _processDeleteUpdate_grpc(unsigned char *data, RET_DATA *rt, unsigned int grpcClientID);
+static void _processUpdateSigning_grpc(unsigned char *data, RET_DATA *rt, unsigned int grpcClientID);
+static bool processValidationRequest_grpc(unsigned char *data, RET_DATA *rt, unsigned int grpcClientID);
+static bool processHandshake_grpc(unsigned char *data, RET_DATA *rt);
+static bool sendSynchRequest_grpc();
+
+extern bool sendError(uint16_t errorCode, ServerSocket* srvSoc, ServerClient* client, bool useQueue);
+extern uint32_t generateIdentifier(uint32_t originAS, IPPrefix* prefix, BGPSecData* data);
+
+__attribute__((always_inline)) inline void printHex(int len, unsigned char* buff) 
+{                                                                                 
+  int i;                                                                          
+  for(i=0; i < len; i++ )                                                         
+  {                                                                               
+      if(i%16 ==0) printf("\n");                                                  
+      printf("%02x ", buff[i]);                                                   
+  }                                                                               
+  printf("\n");                                                                   
+}  
+
+        
+static bool processHandshake_grpc(unsigned char *data, RET_DATA *rt)
+{
+  LOG(LEVEL_INFO, HDR "[SRx server][grpc service] %s function called ", __FUNCTION__);
+  LOG(LEVEL_INFO, HDR "[SRx server][grpc service] grpcServiceHandler : %p  \n", &grpcServiceHandler );
+  LOG(LEVEL_INFO, HDR "[SRx server][grpc service] grpcServiceHandler.CommandQueue   : %p  ", grpcServiceHandler.cmdQueue);
+  LOG(LEVEL_INFO, HDR "[SRx server][grpc service] grpcServiceHandler.CommandHandler : %p  ", grpcServiceHandler.cmdHandler );
+  LOG(LEVEL_INFO, HDR "[SRx server][grpc service] grpcServiceHandler.UpdateCache    : %p  ", grpcServiceHandler.updCache);
+  LOG(LEVEL_INFO, HDR "[SRx server][grpc service] grpcServiceHandler.svrConnHandler : %p  ", grpcServiceHandler.svrConnHandler);
+
+  SRXPROXY_HELLO* hdr  = (SRXPROXY_HELLO*)data;
+  uint32_t proxyID     = 0;
+  uint8_t  clientID    = 0;
+  
+  
+  /* 
+   * To make clientID in accordance with porxyID with proxyMap 
+   */
+  ClientThread* cthread;
+  cthread = (ClientThread*)appendToSList(&grpcServiceHandler.svrConnHandler->svrSock.cthreads, sizeof (ClientThread));
+
+  cthread->active          = true;
+  cthread->initialized     = false;
+  cthread->goodByeReceived = false;
+
+  cthread->proxyID  = 0; // will be changed for srx-proxy during handshake
+  cthread->routerID = 0; // Indicates that it is currently not usable, 
+  //cthread->clientFD = cliendFD;
+  cthread->svrSock  = &grpcServiceHandler.svrConnHandler->svrSock;
+  //cthread->caddr	  = caddr;
+  cthread->type_grpc_client = true;
+
+
+  LOG(LEVEL_INFO, HDR "[SRx server][grpc service](Hello Resonse) Obtained cthread: %p \n", cthread);
+
+
+  if (ntohs(hdr->version) != SRX_PROTOCOL_VER)
+  {
+    RAISE_ERROR("Received Hello packet is of protocol version %u but expected "
+                "is a Hello packet of protocol version %u",
+                ntohs(hdr->version), SRX_PROTOCOL_VER);
+    sendError(SRXERR_WRONG_VERSION, NULL, NULL, false);
+    //sendGoodbye(item->serverSocket, item->client, false);
+  }
+  else
+  {
+    // Figure out the proxyID if it can be used or not. If not, answer with a new proxy ID.
+    proxyID = ntohl(hdr->proxyIdentifier);
+
+    clientID = findClientID(grpcServiceHandler.svrConnHandler, proxyID);
+    if (clientID == 0)
+    {
+      clientID = createClientID(grpcServiceHandler.svrConnHandler);
+    }
+
+
+    if (clientID > 0)
+    {
+      if (!addMapping(grpcServiceHandler.svrConnHandler, proxyID, clientID, cthread, true))
+      {
+        clientID = 0; // FAIL HANDSHAKE
+      }
+
+      LOG(LEVEL_INFO, HDR "[SRx server][grpc service](Hello Resonse) proxyID: 0x%08X --> mapping[clientID:%d] cthread: %p\n", 
+          proxyID,  clientID, grpcServiceHandler.svrConnHandler->proxyMap[clientID].socket);
+    }
+
+    LOG (LEVEL_INFO, "\033[0;36m [SRx server][grpc service](Hello Resonse) Handshake: Connection to proxy[0x%08X] accepted."
+        "Proxy registered as internal client[0x%02X] \033[0m", proxyID, clientID);
+
+    cthread->proxyID  = proxyID;
+    cthread->routerID = clientID;
+
+    grpcServiceHandler.cmdHandler->grpcEnable = true;
+
+    // TODO: client registration should be followed
+    //  _processHandshake()
+    //  command_handler.c: 233 -
+
+
+    /* Send Hello Response */
+    LOG (LEVEL_INFO, HDR "[SRx server][grpc service](Hello Resonse) send Hello Response");
+
+    //bool retVal = true;
+    uint32_t length = sizeof(SRXPROXY_HELLO_RESPONSE);
+    SRXPROXY_HELLO_RESPONSE* pdu = malloc(length);
+    memset(pdu, 0, length);
+
+    pdu->type    = PDU_SRXPROXY_HELLO_RESPONSE;
+    pdu->version = htons(SRX_PROTOCOL_VER);
+    pdu->length  = htonl(length);
+    pdu->proxyIdentifier = htonl(proxyID);
+
+
+    rt->size = length;
+    rt->data = (unsigned char*) malloc(length);
+    memcpy(rt->data, pdu, length);
+    free(pdu);
+
+
+    if(rt->size != 0 && rt->data)
+      cthread->initialized = true;
+
+
+    // This proxy hello function is not stream function, so first it needs to respond
+    // with Hello REsponse value and later have to send 'send sync request' if applicable
+    // In order to do that, send SyncRequest_grpc function should enable some sort of queuing 
+    // mechanism to store 'sync request'
+    //
+    // NOTE : sendSynchRequest  (command_handler.c:307)
+#if 1
+    if (grpcServiceHandler.cmdHandler->sysConfig->syncAfterConnEstablished)
+    {
+      LOG (LEVEL_INFO, HDR "[SRx server][grpc service](Hello Resonse) call sendSyncRequest ");
+      sendSynchRequest_grpc();
+    }
+#endif
+
+    
+    // TODO: send goodbye in case there is error 
+
+  }
+
+  return (rt->size == 0) ? false : true;
+}
+
+static bool processValidationRequest_grpc(unsigned char *data, RET_DATA *rt, unsigned int grpcClientID)
+{
+  LOG(LEVEL_INFO, HDR "[%s] function called, grpc clientID: %d \n", __FUNCTION__, grpcClientID);
+  LOG(LEVEL_INFO, HDR "Enter processValidationRequest");
+    
+  bool retVal = true;
+  SRXRPOXY_BasicHeader_VerifyRequest* hdr =
+                                (SRXRPOXY_BasicHeader_VerifyRequest*)data;
+
+  // Determine if a receipt is requested and a result packet must be send
+  bool     receipt =    (hdr->flags & SRX_FLAG_REQUEST_RECEIPT)
+                      == SRX_FLAG_REQUEST_RECEIPT;
+  // prepare already the send flag. Later on, if this is > 0 send a response.
+  uint8_t  sendFlags = hdr->flags & SRX_FLAG_REQUEST_RECEIPT;
+
+  bool     doOriginVal = (hdr->flags & SRX_FLAG_ROA) == SRX_FLAG_ROA;
+  bool     doPathVal   = (hdr->flags & SRX_FLAG_BGPSEC) == SRX_FLAG_BGPSEC;
+  bool     doAspaVal   = (hdr->flags & SRX_FLAG_ASPA) == SRX_FLAG_ASPA;
+
+  bool      v4     = hdr->type == PDU_SRXPROXY_VERIFY_V4_REQUEST;
+
+  // 1. get an idea what validations are requested:
+  //bool originVal = _isSet(hdr->flags, SRX_PROXY_FLAGS_VERIFY_PREFIX_ORIGIN);
+  //bool pathVal   = _isSet(hdr->flags, SRX_PROXY_FLAGS_VERIFY_PATH);
+  //SRxUpdateID updateID = (SRxUpdateID)item->dataID;
+
+
+  uint32_t requestToken = receipt ? ntohl(hdr->requestToken)
+                                  : DONOTUSE_REQUEST_TOKEN;
+  uint32_t originAS = 0;
+  SRxUpdateID collisionID = 0;
+  SRxUpdateID updateID = 0;
+
+  bool doStoreUpdate = false;
+  IPPrefix* prefix = NULL;
+  // Specify the client id as a receiver only when validation is requested.
+  uint8_t clientID = findClientID(grpcServiceHandler.svrConnHandler, grpcClientID);
+
+  // 1. Prepare for and generate the ID of the update
+  prefix = malloc(sizeof(IPPrefix));
+  memset(prefix, 0, sizeof(IPPrefix));
+  prefix->length     = hdr->prefixLen;
+  BGPSecData bgpData;
+  memset (&bgpData, 0, sizeof(BGPSecData));
+
+  uint8_t* valPtr = (uint8_t*)hdr;
+  AS_TYPE     asType;
+  AS_REL_DIR  asRelDir;
+  AS_REL_TYPE asRelType;
+  if (v4)
+  {
+    SRXPROXY_VERIFY_V4_REQUEST* v4Hdr = (SRXPROXY_VERIFY_V4_REQUEST*)hdr;
+    valPtr += sizeof(SRXPROXY_VERIFY_V4_REQUEST);
+    prefix->ip.version  = 4;
+    prefix->ip.addr.v4  = v4Hdr->prefixAddress;
+    originAS            = ntohl(v4Hdr->originAS);
+    // The next two are in host format for convenience
+    bgpData.numberHops  = ntohs(v4Hdr->bgpsecValReqData.numHops);
+    bgpData.attr_length = ntohs(v4Hdr->bgpsecValReqData.attrLen);
+    // Now in network format as required.
+    bgpData.afi         = v4Hdr->bgpsecValReqData.valPrefix.afi;
+    bgpData.safi        = v4Hdr->bgpsecValReqData.valPrefix.safi;
+    bgpData.local_as    = v4Hdr->bgpsecValReqData.valData.local_as;
+    asType              = v4Hdr->common.asType;
+    asRelType           = v4Hdr->common.asRelType;
+  }
+  else
+  {
+    SRXPROXY_VERIFY_V6_REQUEST* v6Hdr = (SRXPROXY_VERIFY_V6_REQUEST*)hdr;
+    valPtr += sizeof(SRXPROXY_VERIFY_V6_REQUEST);
+    prefix->ip.version  = 6;
+    prefix->ip.addr.v6  = v6Hdr->prefixAddress;
+    originAS            = ntohl(v6Hdr->originAS);
+    // The next two are in host format for convenience
+    bgpData.numberHops  = ntohs(v6Hdr->bgpsecValReqData.numHops);
+    bgpData.attr_length = ntohs(v6Hdr->bgpsecValReqData.attrLen);
+    // Now in network format as required.
+    bgpData.afi         = v6Hdr->bgpsecValReqData.valPrefix.afi;
+    bgpData.safi        = v6Hdr->bgpsecValReqData.valPrefix.safi;
+    bgpData.local_as    = v6Hdr->bgpsecValReqData.valData.local_as;
+    // TODO: v6 protocol 
+    //asType           = ntohl(v6Hdr->asType);
+    //asRelType        = ntohl(v6Hdr->asRelType);
+  }
+
+  // Check if AS path exists and if so then set it
+  if (bgpData.numberHops != 0)
+  {
+    bgpData.asPath = (uint32_t*)valPtr;
+  }
+  // Check if BGPsec path exits and if so then set it
+  if (bgpData.attr_length != 0)
+  {
+    // BGPsec attribute comes after the as4 path
+    bgpData.bgpsec_path_attr = valPtr + (bgpData.numberHops * 4);
+  }
+
+  // 2. Generate the CRC based updateID
+  updateID = generateIdentifier(originAS, prefix, &bgpData);
+  // test for collision and attempt to resolve
+  collisionID = updateID;
+  while(detectCollision(grpcServiceHandler.svrConnHandler->updateCache, &updateID, prefix, originAS, 
+                        &bgpData))
+  {
+    updateID++;
+  }
+  if (collisionID != updateID)
+  {
+    LOG(LEVEL_NOTICE, "UpdateID collision detected!!. The original update ID"
+      " could have been [0x%08X] but was changed to a collision free ID "
+      "[0x%08X]!", collisionID, updateID);
+  }
+  LOG(LEVEL_INFO, HDR "\n[SRx server] Generated Update ID: %08X, client ID:%d \n\n", updateID, clientID);
+
+  //  3. Try to find the update, if it does not exist yet, store it.
+  SRxResult        srxRes;
+  SRxDefaultResult defResInfo;
+  // The method getUpdateResult will initialize the result parameters and
+  // register the client as listener (only if the update already exists)
+  ProxyClientMapping* clientMapping = clientID > 0 ? &grpcServiceHandler.svrConnHandler->proxyMap[clientID]
+                                                   : NULL;
+
+  LOG(LEVEL_INFO, HDR "[SRx Server] proxyMap[clientID:%d]: %p\n", clientID, clientMapping);
+  uint32_t pathId = 0;
+
+  doStoreUpdate = !getUpdateResult (grpcServiceHandler.svrConnHandler->updateCache, &updateID,
+                                    clientID, clientMapping,
+                                    &srxRes, &defResInfo, &pathId);
+
+  LOG(LEVEL_INFO, FILE_LINE_INFO "\033[1;33m ------- Received ASpath info ------- \033[0m");
+  LOG(LEVEL_INFO, "     updateId: [0x%08X] pathID: [0x%08X] "
+      " AS Type: %s  AS Relationship: %s", 
+      updateID, pathId, 
+      asType==2 ? "AS_SEQUENCE": (asType==1 ? "AS_SET": "ETC"),
+      asRelType == 2 ? "provider" : (asRelType == 1 ? "customer":         
+        (asRelType == 3 ? "sibling": (asRelType == 4 ? "lateral" : "unknown"))));
+
+  AS_PATH_LIST *aspl;
+  SRxResult srxRes_aspa; 
+  bool modifyUpdateCacheWithAspaValue = false;
+
+  switch (asRelType)
+  {
+    case AS_REL_CUSTOMER:
+      asRelDir = ASPA_UPSTREAM; break;
+    case AS_REL_PROVIDER:
+      asRelDir = ASPA_DOWNSTREAM; break;
+    case AS_REL_SIBLING:
+      asRelDir = ASPA_UPSTREAM; break;
+    case AS_REL_LATERAL:
+      asRelDir = ASPA_DOWNSTREAM; break;
+    default:
+      asRelDir = ASPA_UNKNOWNSTREAM;     
+  }
+
+
+  if (pathId == 0)  // if not found in  cEntry
+  {
+    pathId = makePathId(bgpData.numberHops, bgpData.asPath, asType, true);
+    LOG(LEVEL_INFO, FILE_LINE_INFO " generated Path ID : %08X ", pathId);
+
+    // to see if there is already exist or not in AS path Cache with path id
+    aspl = getAspathListFromAspathCache (grpcServiceHandler.svrConnHandler->aspathCache, pathId, &srxRes_aspa);
+    
+    // AS Path List already exist in Cache
+    if(aspl)
+    {
+      // once found aspa result value in Cache, no need to validate operation
+      //  this value is some value not undefined
+      if (srxRes_aspa.aspaResult == SRx_RESULT_UNDEFINED)
+      {
+        LOG(LEVEL_INFO, FILE_LINE_INFO " Already registered with the previous pdu");
+      }
+      else
+      {
+        // in case the same update message comes from same peer, even though same update, 
+        // bgpsec pdu is different, so that it results in a new updateID, which in turn 
+        // makes not found in updatecahe. So this case makes not found pathId, but aspath cache 
+        // stores srx result value in db with the matched path id. So srxRes_aspa.aspaResult is
+        // not undefined
+        LOG(LEVEL_INFO, FILE_LINE_INFO " ASPA validation Result[%d] is already exist", srxRes_aspa.aspaResult);
+
+        // Modify UpdateCache's srx Res -> aspaResult with srxRes_aspa.aspaResult
+        // But UpdateCache's cEntry here dosen't exist yet
+        // so, after calling storeUpdate, put this value into cEntry directly
+        modifyUpdateCacheWithAspaValue = true;
+      }
+
+      srxRes.aspaResult = srxRes_aspa.aspaResult;
+
+    }
+    // AS Path List not exist in Cache
+    else
+    {
+      aspl = newAspathListEntry(bgpData.numberHops, bgpData.asPath, pathId, asType, asRelDir, bgpData.afi, true);
+      if(!aspl)
+      {
+        LOG(LEVEL_ERROR, " memory allocation for AS path list entry resulted in fault");
+        //return false;
+      }
+  
+      if (doStoreUpdate)
+      {
+        defResInfo.result.aspaResult = hdr->aspaDefRes; // router's input value (Undefined, Unverifiable, Invalid)
+        defResInfo.resSourceASPA     = hdr->aspaResSrc;
+      }
+
+      // in order to free aspl, need to copy value inside the function below
+      //
+      storeAspathList(grpcServiceHandler.svrConnHandler->aspathCache, &defResInfo, pathId, asType, aspl);
+      srxRes.aspaResult   = defResInfo.result.aspaResult;
+
+    }
+    // free 
+    if (aspl)
+      deleteAspathListEntry(aspl);
+  }
+
+  // -------------------------------------------------------------------
+
+  if (doStoreUpdate)
+  {
+    defResInfo.result.roaResult    = hdr->roaDefRes;
+    defResInfo.resSourceROA        = hdr->roaResSrc;
+
+    defResInfo.result.bgpsecResult = hdr->bgpsecDefRes;
+    defResInfo.resSourceBGPSEC     = hdr->bgpsecResSrc;
+
+    if (!storeUpdate(grpcServiceHandler.svrConnHandler->updateCache, clientID, clientMapping,
+                     &updateID, prefix, originAS, &defResInfo, &bgpData, pathId))
+    {
+      RAISE_SYS_ERROR("Could not store update [0x%08X]!!", updateID);
+      free(prefix);
+      return false;
+    }
+
+    // Use the default result.
+    srxRes.roaResult    = defResInfo.result.roaResult;
+    srxRes.bgpsecResult = defResInfo.result.bgpsecResult;
+  }
+  free(prefix);
+  prefix = NULL;
+
+  LOG(LEVEL_INFO, HDR "+ from update cache srxRes.roaResult : %02x", srxRes.roaResult);
+  LOG(LEVEL_INFO, HDR "+ from update cache srxRes.bgpsecResult : %02x", srxRes.bgpsecResult);
+  LOG(LEVEL_INFO, HDR "+ from update cache srxRes.aspaesult : %02x", srxRes.aspaResult);
+
+
+  if (modifyUpdateCacheWithAspaValue)
+  {
+    // modify UpdateCache with srxRes_aspa.aspaResult, then later this value 
+    // in UpdateCahe will be used 
+    modifyUpdateCacheResultWithAspaVal(grpcServiceHandler.svrConnHandler->updateCache, &updateID, &srxRes_aspa);
+
+  }
+
+  // Just check if the client has the correct values for the requested results
+  if (doOriginVal && (hdr->roaDefRes != srxRes.roaResult))
+  {
+    sendFlags = sendFlags | SRX_FLAG_ROA;
+  }
+  if (doPathVal && (hdr->bgpsecDefRes != srxRes.bgpsecResult))
+  {
+    sendFlags = sendFlags | SRX_FLAG_BGPSEC;
+  }
+
+
+  LOG(LEVEL_DEBUG, HDR"\033[0;35m sendflag: %x \033[0m", sendFlags);
+  if (sendFlags > 0) // a notification is needed. flags specifies the type
+  {
+    // TODO: Check specification if we can send a receipt without results, if
+    // not the following 6 lines MUST be included, otherwise not.
+    if (doOriginVal)
+    {
+      sendFlags = sendFlags | SRX_FLAG_ROA;
+    }
+    if (doPathVal)
+    {
+      sendFlags = sendFlags | SRX_FLAG_BGPSEC;
+    }
+    if (doAspaVal)
+    {
+      sendFlags = sendFlags | SRX_FLAG_ASPA;
+    }
+
+  
+    // Now send the results we know so far;
+    
+    /*
+       sendVerifyNotification(svrSock, client, updateID, sendFlags,
+       requestToken, srxRes.roaResult,
+       srxRes.bgpsecResult,
+       !self->sysConfig->mode_no_sendqueue);
+    */
+
+    uint32_t length = sizeof(SRXPROXY_VERIFY_NOTIFICATION);
+    SRXPROXY_VERIFY_NOTIFICATION* pdu = malloc(length);
+    memset(pdu, 0, length);
+
+    pdu->type          = PDU_SRXPROXY_VERI_NOTIFICATION;
+    pdu->resultType    = sendFlags;
+    pdu->requestToken  = htonl(requestToken);
+    pdu->roaResult     = srxRes.roaResult;
+    pdu->bgpsecResult  = srxRes.bgpsecResult;
+    pdu->aspaResult    = srxRes.aspaResult;
+    pdu->length        = htonl(length);
+    pdu->updateID      = htonl(updateID);
+
+    if ((pdu->requestToken != 0) && (sendFlags < SRX_FLAG_REQUEST_RECEIPT))
+    {
+      LOG(LEVEL_NOTICE, "Send a notification of update 0x%0aX with request "
+          "token 0x%08X but no receipt flag set!", updateID, requestToken);
+    }
+
+    pdu->length = htonl(length);
+
+    // return value for response grpc
+    rt->size = length;
+    rt->data = (unsigned char*) malloc(length);
+    memcpy(rt->data, pdu, length);
+    free(pdu);
+
+    printf("rt size: %d\n", rt->size);
+    printf("rt data: \n");
+    printHex(rt->size, rt->data);
+  
+    if ((doOriginVal || doPathVal || doAspaVal) && ((sendFlags & SRX_FLAG_ROA_BGPSEC_ASPA) > 0))
+    {
+      rt->info = 0x1; // queue enable info
+      printf("rt info: %x\n", rt->info);
+
+      // Only keep the validation flags.
+      hdr->flags = sendFlags & SRX_FLAG_ROA_BGPSEC_ASPA;
+
+      /*
+      if (!queueCommand(grpcServiceHandler.cmdQueue, COMMAND_TYPE_SRX_PROXY, NULL, NULL,
+            updateID, ntohl(hdr->length), (uint8_t*)hdr))
+      //  TODO XXX: should I put a client thread to queue command function above instead of NULL ?
+      //    --> client thread (ClientThread*) was created and associated with the info 
+      //    from server_socket.c::runServerLoop()
+      //
+      //    --> (Answer) No need, because _processUpdateValidation() doesn't use client thread at all
+      {
+        RAISE_ERROR("Could not add validation request to command queue!");
+        retVal = false;
+      }
+      */
+    }
+
+    LOG(LEVEL_INFO, HDR "Exit processValidationRequest", pthread_self());
+
+  }
+  return retVal;
+}
+
+
+void RunQueueCommand(int size, unsigned char *data, RET_DATA *rt, unsigned int grpcClientID)
+{
+  
+  LOG(LEVEL_INFO, HDR "[%s] for Notification Queueing Command", __FUNCTION__);
+  printHex(size, data);
+
+  LOG(LEVEL_INFO, HDR "[%s] rt size: %d\n", __FUNCTION__, rt->size);
+  LOG(LEVEL_INFO, HDR "[%s] rt data: \n", __FUNCTION__);
+  printHex(rt->size, rt->data);
+
+  SRXRPOXY_BasicHeader_VerifyRequest* hdr =
+    (SRXRPOXY_BasicHeader_VerifyRequest*)data;
+
+  SRXPROXY_VERIFY_NOTIFICATION* pdu = (SRXPROXY_VERIFY_NOTIFICATION*)rt->data;
+
+  SRxUpdateID updateID = 0;
+  updateID = ntohl(pdu->updateID);
+  LOG(LEVEL_INFO, HDR "[%s] updateID: %08x hdr length: %d\n", __FUNCTION__, updateID, ntohl(hdr->length));
+
+
+  // create the validation command! 
+  // here, do not need server sock and client thread (3rd, 4th parameter below)
+  if (!queueCommand(grpcServiceHandler.cmdQueue, COMMAND_TYPE_SRX_PROXY, NULL, NULL,
+        updateID, ntohl(hdr->length), (uint8_t*)hdr))
+  {
+    RAISE_ERROR("Could not add validation request to command queue!");
+  }
+}
+
+void RunQueueCommand_uid(int size, unsigned char *data, uint32_t updateId, unsigned int grpcClientID)
+{
+  LOG(LEVEL_INFO, HDR "[%s] for General purpose Queueing Command", __FUNCTION__);
+  printHex(size, data);
+
+
+  SRxUpdateID updateID = 0;
+
+  SRXPROXY_DELETE_UPDATE*  duHdr = NULL;
+
+  SRXPROXY_BasicHeader*    bhdr  = NULL; 
+  bhdr = (SRXPROXY_BasicHeader*)data;
+
+  switch (bhdr->type)                   
+  {                                     
+    case PDU_SRXPROXY_DELTE_UPDATE:
+      duHdr = (SRXPROXY_DELETE_UPDATE*)data;
+      updateID = ntohl(duHdr->updateIdentifier);
+      break;
+
+    default:
+      break;
+  }
+
+  uint8_t  clientID    = 0;
+  clientID = findClientID(grpcServiceHandler.svrConnHandler, grpcClientID);
+
+  // find cthread from client ID 
+  ClientThread* cthread = NULL;
+  SListNode* node =  getRootNodeOfSList(&grpcServiceHandler.svrConnHandler->svrSock.cthreads);
+    
+  while (!(node == NULL))
+  {
+      cthread = (ClientThread*)node->data;
+      if (cthread && cthread->proxyID == grpcClientID)
+        break;
+      node = node->next;
+  }
+
+
+  LOG(LEVEL_INFO, HDR "[%s] updateID: %08x duHdr length: %d clientID: %d\n",
+      __FUNCTION__, updateID, ntohl(duHdr->length), clientID);
+
+  if (!queueCommand(grpcServiceHandler.cmdQueue, COMMAND_TYPE_SRX_PROXY, 
+        &grpcServiceHandler.svrConnHandler->svrSock, cthread,
+        updateID, ntohl(duHdr->length), (uint8_t*)duHdr))
+  {
+    RAISE_ERROR("Could not add validation request to command queue!");
+  }
+}
+
+static void _processUpdateSigning_grpc(unsigned char *data, RET_DATA *rt, unsigned int grpcClientID)
+{
+  // TODO Sign the data
+  LOG(LEVEL_INFO, "Signing of updates is currently not supported!");
+}
+
+//static void _processDeleteUpdate(CommandHandler* cmdHandler, CommandQueueItem* item)
+static void _processDeleteUpdate_grpc(unsigned char *data, RET_DATA *rt, unsigned int grpcClientID)
+{
+
+  CommandHandler* cmdHandler =  grpcServiceHandler.cmdHandler;
+
+  // TODO: replace item with real pointer variable
+  CommandQueueItem* item=NULL;
+  // For now the delete will NOT remove the update from the cache. It will
+  // remove the client - update association though or return an error in case
+  // no association existed.
+  SRxUpdateID   updateID = (SRxUpdateID)item->dataID;
+  ClientThread* clThread = (ClientThread*)item->client;
+  SRXPROXY_DELETE_UPDATE* duHdr = (SRXPROXY_DELETE_UPDATE*)item->data;
+
+  if (deleteUpdateFromCache(cmdHandler->updCache, clThread->routerID,
+                            &updateID, htons(duHdr->keepWindow)))
+  {
+    // Reduce the updates by one. BZ308
+    cmdHandler->svrConnHandler->proxyMap[clThread->routerID].updateCount--;
+  }
+  else
+  {
+    // The update was either not found or the client was not associated to the
+    // specified update.
+    sendError(SRXERR_UPDATE_NOT_FOUND, item->serverSocket, item->client, false);
+    LOG(LEVEL_NOTICE, "Deletion request for update [0x%08X] from client "
+                      "[0x%02X] failed, update not found in update cache!");
+  }
+}
+
+static void _processPeerChange_grpc(unsigned char *data, RET_DATA *rt, unsigned int grpcClientID)
+{
+  // TODO@ add code for deletion of peer data
+  LOG(LEVEL_WARNING, "Peer Changes are not supported prior Version 0.4.0!");
+}
+
+
+// Called by Go module
+//int responseGRPC (int size, unsigned char* data)
+RET_DATA responseGRPC (int size, unsigned char* data, unsigned int grpcClientID)
+{
+    setLogLevel(LEVEL_INFO);
+    LOG(LEVEL_INFO, HDR "response GRPC call");
+    LOG(LEVEL_INFO, HDR "[SRx server] [%s] calling - size: %d, grpcClient ID: %02x", __FUNCTION__, size, grpcClientID);
+
+    /*
+    bool ret = _isSet(0x03, 0x01);
+    printf("ret bool: %d \n", ret);
+    */
+
+    LogLevel lv = getLogLevel();
+    LOG(LEVEL_INFO, HDR "srx server log Level: %d", lv);
+
+    if (lv >= LEVEL_INFO) {
+      printf(" ---- received data ----\n");
+      printHex(size, data);
+      printf(" -----------------------\n");
+    }
+
+    RET_DATA rt;
+    memset(&rt, 0x0, sizeof(RET_DATA));
+
+    /* (examples)
+     *
+    rt.data = (unsigned char*) malloc(size);
+    rt.size = size;
+
+    memset(rt.data, 0x00, size);
+    rt.data[0] = 0xAF; rt.data[1] = 0x11; rt.data[2] = 0x12; 
+    rt.data[3] = 0x33; rt.data[4] = 0xAB; rt.data[5] = 0xCD; rt.data[6] = 0xEF;
+    */
+
+    SRXPROXY_BasicHeader* bhdr = (SRXPROXY_BasicHeader*)data;
+    uint8_t clientID;
+    ClientThread* cthread;
+          
+    uint32_t length = sizeof(SRXPROXY_GOODBYE);     
+    uint8_t pdu[length];                            
+    SRXPROXY_GOODBYE* hdr = (SRXPROXY_GOODBYE*)pdu; 
+
+    switch (bhdr->type)
+    {                   
+      case PDU_SRXPROXY_HELLO:
+        processHandshake_grpc(data, &rt);
+        break;
+
+      case PDU_SRXPROXY_VERIFY_V4_REQUEST:
+      case PDU_SRXPROXY_VERIFY_V6_REQUEST:
+        processValidationRequest_grpc(data, &rt, grpcClientID);
+        break;
+
+      case PDU_SRXPROXY_SIGN_REQUEST:
+        _processUpdateSigning_grpc(data, &rt, grpcClientID);
+        break;
+      case PDU_SRXPROXY_GOODBYE:
+        LOG(LEVEL_INFO, HDR "[SRx Server] Received GOOD BYE from proxyID: %d\n", grpcClientID);
+        clientID = findClientID(grpcServiceHandler.svrConnHandler, grpcClientID);
+      
+        LOG(LEVEL_INFO, HDR "[SRx server] proxyID: %d --> mapping[clientID:%d] cthread: %p\n", 
+          grpcClientID,  clientID, grpcServiceHandler.svrConnHandler->proxyMap[clientID].socket);
+
+        cthread = (ClientThread*)grpcServiceHandler.svrConnHandler->proxyMap[clientID].socket;
+        // in order to skip over terminating a client pthread which was not generated if grpc enabled
+        cthread->active  = false;
+        closeClientConnection(&grpcServiceHandler.cmdHandler->svrConnHandler->svrSock, cthread);
+
+        //clientID = ((ClientThread*)item->client)->routerID;
+        deactivateConnectionMapping(grpcServiceHandler.svrConnHandler, clientID, false, 0);
+        deleteFromSList(&grpcServiceHandler.cmdHandler->svrConnHandler->clients, cthread);
+        grpcServiceHandler.cmdHandler->grpcEnable = false;
+        LOG(LEVEL_INFO, HDR "GoodBye!", pthread_self());
+        break;
+
+      case PDU_SRXPROXY_DELTE_UPDATE:
+        //_processDeleteUpdate(cmdHandler, item);
+        _processDeleteUpdate_grpc(data, &rt, grpcClientID);
+        break;
+      case PDU_SRXPROXY_PEER_CHANGE:
+        //_processPeerChange(cmdHandler, item);
+        _processPeerChange_grpc(data, &rt, grpcClientID);
+        break;
+      default:
+        RAISE_ERROR("Unknown/unsupported pdu type: %d", bhdr->type);
+
+        memset(pdu, 0, length);                         
+        LOG(LEVEL_INFO, HDR" send Goodbye! called" );  
+        hdr->type       = PDU_SRXPROXY_GOODBYE;         
+        hdr->keepWindow = htons(900);            
+        hdr->length     = htonl(length);                
+
+        LOG(LEVEL_INFO, HDR "\n\nCalling CallBack function forGoodbye STREAM\n\n");         
+        cb_proxyGoodBye(*hdr);
+        
+        // XXX: NOTE: do the same way in GoodBye above
+        clientID = findClientID(grpcServiceHandler.svrConnHandler, grpcClientID);
+        LOG(LEVEL_INFO, HDR "[SRx server] proxyID: %d --> mapping[clientID:%d] cthread: %p\n", 
+          grpcClientID,  clientID, grpcServiceHandler.svrConnHandler->proxyMap[clientID].socket);
+        cthread = (ClientThread*)grpcServiceHandler.svrConnHandler->proxyMap[clientID].socket;
+        cthread->active  = false;
+        closeClientConnection(&grpcServiceHandler.cmdHandler->svrConnHandler->svrSock, cthread);
+        deactivateConnectionMapping(grpcServiceHandler.svrConnHandler, clientID, false, 0);
+        deleteFromSList(&grpcServiceHandler.cmdHandler->svrConnHandler->clients, cthread);
+        grpcServiceHandler.cmdHandler->grpcEnable = false;
+        LOG(LEVEL_INFO, HDR "GoodBye!", pthread_self());
+    }
+
+    printf("======= [SRx server][responseGRPC] [pdu type: %d]======= \n "
+        " final Return data which will be sent to the client\n", bhdr->type);
+    printHex(rt.size, rt.data);
+    return rt;
+}
+
+
+
+
+static bool sendSynchRequest_grpc()
+//static bool sendSynchRequest_grpc(proxy, grpc id ...etc)
+{
+  bool retVal = true;
+  uint32_t length = sizeof(SRXPROXY_SYNCH_REQUEST);
+  SRXPROXY_SYNCH_REQUEST* pdu = malloc(length);
+  memset(pdu, 0, length);
+
+  pdu->type      = PDU_SRXPROXY_SYNC_REQUEST;
+  pdu->length    = htonl(length);
+
+      
+  LOG (LEVEL_INFO, HDR "[SRx server][sendSynchRequest](Hello Resonse) using queue-command to send sync request to client ");
+  if (!queueCommand(grpcServiceHandler.cmdQueue, COMMAND_TYPE_SRX_PROXY, NULL, NULL,
+        0, length, (uint8_t*)pdu))
+  {
+    RAISE_ERROR("Could not add validation request to command queue!");
+    retVal = false;
+  }
+
+  // call cb proxyStream callback function
+  //cb_proxyStream(length, pdu);
+  free(pdu);
+
+
+  return retVal;
+}
+
+
+
+
+
+
+
+
+
--- ./server/grpc_service.h	1969-12-31 19:00:00.000000000 -0500
+++ ./server/grpc_service.h	2021-11-22 21:25:23.373963556 -0500
@@ -0,0 +1,47 @@
+#ifndef GRPC_SERVICE_H
+#define	GRPC_SERVICE_H
+
+#include "server/command_queue.h"
+#include "server/command_handler.h"
+#include "server/update_cache.h"
+#include "shared/srx_packets.h"
+#include "util/log.h"
+#include "server/server_connection_handler.h"
+
+typedef struct {
+  // Arguments (create)
+  CommandQueue*             cmdQueue;
+  CommandHandler*           cmdHandler;
+  ServerConnectionHandler*  svrConnHandler;
+  //BGPSecHandler*            bgpsecHandler;
+  //RPKIHandler*              rpkiHandler;
+  UpdateCache*              updCache;
+
+  // Argument (start)
+  //CommandQueue*             queue;
+  uint32_t                  grpc_port;
+
+} GRPC_ServiceHandler;
+
+GRPC_ServiceHandler     grpcServiceHandler;
+
+
+typedef struct {
+    unsigned int size;
+    unsigned char *data;
+    unsigned char info;
+} RET_DATA;
+
+//int responseGRPC (int size);
+//int responseGRPC (int size, unsigned char* data);
+RET_DATA responseGRPC (int size, unsigned char* data, unsigned int grpcClientID);
+void RunQueueCommand(int size, unsigned char *data, RET_DATA *rt, unsigned int grpcClientID);
+void RunQueueCommand_uid(int size, unsigned char *data, uint32_t updateId, unsigned int grpcClientID);
+
+
+
+#endif /* GRPC_SERVICE_H */
+
+
+
+
--- ./server/main.c	2021-11-23 14:56:24.715374748 -0500
+++ ./server/main.c	2021-11-22 21:25:23.374963562 -0500
@@ -105,6 +105,10 @@
 #include "server/aspa_trie.h"
 #include "util/directory.h"
 #include "util/log.h"
+#ifdef USE_GRPC
+#include "server/grpc_service.h"
+#include "server/libsrx_grpc_server.h"
+#endif
 
 // Some defines needed for east
 #define SETUP_RPKI_HANDLER         1
@@ -181,6 +185,12 @@ static void doCleanupHandlers(int handle
 /** Holds the SRxCryptoAPI */
 SRxCryptoAPI* g_capi = NULL;
 
+#ifdef USE_GRPC
+static void* gRPCService(void* arg);
+void createGRPCService();
+extern GRPC_ServiceHandler     grpcServiceHandler;
+#endif
+
 ////////////////////
 // Server Call backs
 ////////////////////
@@ -768,6 +778,10 @@ int main(int argc, const char* argv[])
       }
       else
       {
+#ifdef USE_GRPC
+        createGRPCService();
+        LOG(LEVEL_INFO, HDR "[server] created GRPC Service thread\n");
+#endif
         // Ready for requests
         cleanupRequired = true;
         run();
@@ -809,3 +823,55 @@ int main(int argc, const char* argv[])
   }
   return exitCode;
 }
+
+#ifdef USE_GRPC
+void createGRPCService()
+{
+  pthread_t tid;
+  pthread_attr_t attr;
+  pthread_attr_init(&attr);
+  pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
+  LOG(LEVEL_INFO, HDR "+ pthread grpc service started (port:%d)...\n", pthread_self(), config.grpc_port);
+
+  /* init service handler */
+  grpcServiceHandler.cmdQueue   = &cmdQueue;
+  grpcServiceHandler.cmdHandler = &cmdHandler;
+  grpcServiceHandler.updCache = &updCache;
+  grpcServiceHandler.svrConnHandler = &svrConnHandler;
+  grpcServiceHandler.grpc_port  = config.grpc_port;
+
+  LOG(LEVEL_DEBUG,  "+ grpcServiceHandler : %p  \n", &grpcServiceHandler );
+  LOG(LEVEL_DEBUG,  "+ grpcServiceHandler.CommandQueue   : %p  \n", grpcServiceHandler.cmdQueue);
+  LOG(LEVEL_DEBUG,  "+ grpcServiceHandler.CommandHandler : %p  \n", grpcServiceHandler.cmdHandler );
+  LOG(LEVEL_DEBUG,  "+ grpcServiceHandler.UpdateCache    : %p  \n", grpcServiceHandler.updCache);
+  LOG(LEVEL_DEBUG,  "+ grpcServiceHandler.svrConnHandler : %p  \n", grpcServiceHandler.svrConnHandler);
+  LOG(LEVEL_INFO ,  "+ grpcServiceHandler.grpc_port      : %d  \n", grpcServiceHandler.grpc_port);
+
+  LOG(LEVEL_INFO, "Init Worker Pool");
+  InitWorkerPool();
+
+  // TODO: instead of cmd Handler as a argument, need more relavant variables such as port number
+  int ret = pthread_create(&tid, &attr, gRPCService, &grpcServiceHandler);
+  if (ret != 0)
+  {
+    RAISE_ERROR("Failed to create a grpc thread");
+  }
+
+  pthread_join(tid, NULL);
+  LOG(LEVEL_INFO, HDR "grpc service thread STOPPED and going to joinable status");
+  LOG(LEVEL_INFO, HDR "+ pthread grpc service thread stopped and going to joinable status\n");
+}
+
+static void* gRPCService(void* arg)
+{
+  GRPC_ServiceHandler* grpcSH = arg;
+  LOG(LEVEL_INFO, HDR "++ gRPC Server Thread started (port:%d)", pthread_self(), grpcSH->grpc_port);
+  LOG(LEVEL_INFO, HDR "++ pthread grpc service thread started...\n");
+
+  Serve(grpcSH->grpc_port);
+
+  pthread_exit(0);
+}
+#endif
+
+
--- ./server/server_connection_handler.c	2021-11-23 14:56:24.717374759 -0500
+++ ./server/server_connection_handler.c	2021-11-22 21:25:23.376963573 -0500
@@ -689,9 +689,9 @@ bool processValidationRequest(ServerConn
     case AS_REL_PROVIDER:
       asRelDir = ASPA_DOWNSTREAM; break;
     case AS_REL_SIBLING:
-      asRelDir = ASPA_UPSTREAM; break;
-    case AS_REL_LATERAL:
       asRelDir = ASPA_DOWNSTREAM; break;
+    case AS_REL_LATERAL:
+      asRelDir = ASPA_UPSTREAM; break;
     default:
       asRelDir = ASPA_UNKNOWNSTREAM;     
   }
@@ -1491,6 +1491,10 @@ bool addMapping(ServerConnectionHandler*
   // Now if still ok, get the map element belonging to the clientID
   if (ok)
   {
+  
+#ifdef USE_GRPC
+    ClientThread* cthread = (ClientThread*)cSocket;
+#endif // USE_GRPC
     LOG(LEVEL_INFO,"Register proxyID[0x%08X] as clientID[0x%08X]",
         proxyID, clientID);
     if (self->proxyMap[clientID].proxyID == 0)
@@ -1503,6 +1507,12 @@ bool addMapping(ServerConnectionHandler*
     self->proxyMap[clientID].socket     = cSocket;
     self->proxyMap[clientID].isActive   = activate;
     self->proxyMap[clientID].crashed    = 0;
+#ifdef USE_GRPC
+    if(cthread && cthread->type_grpc_client)
+    {
+      self->proxyMap[clientID].grpcClient = true;
+    }
+#endif
     if (!activate)
     {
       // The mapping gets added. if not active is is considered pre-configured.
@@ -1618,6 +1628,9 @@ void deactivateConnectionMapping(ServerC
   self->proxyMap[clientID].crashed = crashed ? time.tv_sec : 0;
   _delMapping(self, clientID, keepWindow);
   self->proxyMap[clientID].updateCount = 0;
+#ifdef USE_GRPC
+  self->proxyMap[clientID].grpcClient = false;
+#endif
 }
 
 /**
@@ -1631,3 +1644,5 @@ void markConnectionHandlerShutdown(Serve
 {
   self->inShutdown = true;
 }
+
+
--- ./server/server_connection_handler.h	2021-11-23 14:56:24.717374759 -0500
+++ ./server/server_connection_handler.h	2021-11-22 21:25:23.376963573 -0500
@@ -86,6 +86,9 @@ typedef struct {
   /** Number of updates assigned to this client. This allows a more efficient
    * cleanup. */
   uint32_t updateCount;  
+#ifdef USE_GRPC
+  bool grpcClient;
+#endif
 } ProxyClientMapping;
 
 #define MAX_PROXY_CLIENT_ELEMENTS MAX_PROXY_MAPPINGS
--- ./server/srx_packet_sender.c	2021-11-23 14:56:24.718374765 -0500
+++ ./server/srx_packet_sender.c	2021-11-22 21:25:23.376963573 -0500
@@ -641,13 +641,16 @@ bool sendError(uint16_t errorCode, Serve
   pdu->type      = PDU_SRXPROXY_ERROR;
   pdu->errorCode = htons(errorCode);
   pdu->length    = htonl(length);
-
+#ifdef USE_GRPC
+   cb_proxyCallbackHandler_Service(length, pdu);
+#else
   // Send the pdu to the client
   if (!__sendPacketToClient(srvSoc, client, pdu, length, useQueue))
   {
     RAISE_SYS_ERROR("Could not send the error report type [%0x04X]", errorCode);
     retVal = false;
   }
+#endif
   free(pdu);
 
   return retVal;
--- ./shared/srx_packets.h	2021-11-23 14:56:24.720374776 -0500
+++ ./shared/srx_packets.h	2021-11-22 21:25:23.378963585 -0500
@@ -167,8 +167,8 @@ typedef struct {
   uint16_t  version;
   uint8_t   reserved8;
   uint32_t  zero32;
-  uint32_t  length;            // 12 Bytes
-  uint32_t  proxyIdentifier;
+  uint32_t  length;            
+  uint32_t  proxyIdentifier;    // 16 Bytes
 } __attribute__((packed)) SRXPROXY_HELLO_RESPONSE;
 
 /**
@@ -179,7 +179,7 @@ typedef struct {
   uint16_t  keepWindow;
   uint8_t   reserved8;
   uint32_t  zero32;
-  uint32_t  length;            // 8 Bytes
+  uint32_t  length;            // 12 Bytes
 } __attribute__((packed)) SRXPROXY_GOODBYE;
 
 typedef struct {
--- ./tools/rpkirtr_client.c	2021-11-23 14:56:24.721374782 -0500
+++ ./tools/rpkirtr_client.c	2021-11-22 21:25:23.379963590 -0500
@@ -365,7 +365,7 @@ void syntax(const char* prgName)
     printf ("    The order in which the data is printed is ASN, Prefix, Maxlen");
     printf ("\n    This means the formating string must contain the order");
     printf ("\n    integer - string - integer");
-    printf ("\n\n 2010-%s ANTD NIST - Version %s\n", SRX_DEV_TOYEAR, SRX_TOOLS_VERSION);
+    printf ("\n\n 2010-%s NIST - Version %s\n", SRX_DEV_TOYEAR, SRX_TOOLS_VERSION);
 }
 
 /**
--- ./tools/rpkirtr_svr.c	2021-11-23 14:56:24.721374782 -0500
+++ ./tools/rpkirtr_svr.c	2021-11-22 21:25:23.379963590 -0500
@@ -185,7 +185,7 @@
 #include "util/prefix.h"
 
 // Max characters per line
-#define LINE_BUF_SIZE 255
+#define LINE_BUF_SIZE 4096
 
 /** This structure specified one cache entry. */
 typedef struct {
--- ./tools/srxsvr_client.c	2021-11-23 14:56:24.722374787 -0500
+++ ./tools/srxsvr_client.c	2021-11-22 21:25:23.380963596 -0500
@@ -117,6 +117,9 @@
 #include "util/prefix.h"
 #include "util/str.h"
 #include "util/socket.h"
+#ifdef USE_GRPC
+#include "client/grpc_client_service.h"
+#endif
 
 #define DEFAULT_SERVER    "localhost"
 #define DEFAULT_PORT      17900
@@ -132,6 +135,11 @@
 #define CMD_HELP       "help"
 #define CMD_CREDITS    "credits"
 #define CMD_CONNECT    "connect"
+#ifdef USE_GRPC
+#define CMD_CONNECT_GRPC "connect_grpc"
+#define CMD_VERIFY_GRPC  "verify_grpc"
+#define CMD_VERIFY_DB_GRPC  "verify_db_grpc"
+#endif
 #define CMD_DISCONNECT "disconnect"
 #define CMD_RECONNECT  "reconnect"
 #define CMD_ADD_PEER   "addPeer"
@@ -157,8 +165,13 @@
 // since 0.3.0
 static char* cmd_code[] = {
              CMD_QUIT, CMD_EXIT, CMD_HELP, CMD_CREDITS,
+#ifdef USE_GRPC
+             CMD_CONNECT, CMD_CONNECT_GRPC, CMD_DISCONNECT, CMD_RECONNECT,
+             CMD_ADD_PEER, CMD_DEL_PEER, CMD_VERIFY, CMD_VERIFY_GRPC, CMD_VERIFY_DB_GRPC, CMD_SIGN, CMD_DELETE, 
+#else
              CMD_CONNECT, CMD_DISCONNECT, CMD_RECONNECT,
              CMD_ADD_PEER, CMD_DEL_PEER, CMD_VERIFY, CMD_SIGN, CMD_DELETE, 
+#endif
              CMD_RUN, 
              CMD_STAT_START, CMD_STAT_STOP, CMD_STAT_INIT, 
              CMD_STAT_MARK_NO_RECEIPT, CMD_STAT_MARK_WITH_RECEIPT, 
@@ -174,7 +187,7 @@ static bool isBlocking = true;
 /** See writeLog. */
 static bool keepGoing    = true;
 static SRxProxy* proxy   = NULL;
-static LogLevel logLevel = LEVEL_ERROR;
+static LogLevel logLevel = LEVEL_DEBUG; /*LEVEL_ERROR;*/
 
 // Forward declaration
 void doDisconnect(bool log);
@@ -203,6 +216,10 @@ static bool     stat_exit_on_mark = fals
 static struct timespec stat_startTime;
 static struct timespec stat_stopTime;
 
+#ifdef USE_GRPC
+void doConnect_grpc(bool log, char** argPtr);
+void doVerify_grpc(bool log, char** argPtr);
+#endif
 /**
  * Increments the notification counter. This number contains the notifications
  * of type receipt.
@@ -1389,6 +1406,25 @@ void doVerify(bool log, char** argPtr)
   // @TODO: Generate some test data for input
   bgpsecInput = prompt(argPtr, "(Verify) BGPSEC some string ? ");
 
+
+
+  /* 
+   *  on command line, "verify 1 3 65005 100.1.0.0/24 3 3" without bgpsec string,
+   *  then will fall into this following code
+   */
+  char aspath[] = {
+      0x00, 0x00, 0xfd, 0xf3,
+  };
+  char bgpsec_pattr[] = {
+      0x90, 0x21, 0x00, 0x69, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0xfd, 0xf3, 0x00, 0x61, 0x01, 0xc3,
+      0x04, 0x33, 0xfa, 0x19, 0x75, 0xff, 0x19, 0x31, 0x81, 0x45, 0x8f, 0xb9, 0x02, 0xb5, 0x01, 0xea,
+      0x97, 0x89, 0xdc, 0x00, 0x48, 0x30, 0x46, 0x02, 0x21, 0x00, 0xbd, 0x92, 0x9e, 0x69, 0x35, 0x6e,
+      0x7b, 0x6c, 0xfe, 0x1c, 0xbc, 0x3c, 0xbd, 0x1c, 0x4a, 0x63, 0x8d, 0x64, 0x5f, 0xa0, 0xb7, 0x20,
+      0x7e, 0xf3, 0x2c, 0xcc, 0x4b, 0x3f, 0xd6, 0x1b, 0x5f, 0x46, 0x02, 0x21, 0x00, 0xb6, 0x0a, 0x7c,
+      0x82, 0x7f, 0x50, 0xe6, 0x5a, 0x5b, 0xd7, 0x8c, 0xd1, 0x81, 0x3d, 0xbc, 0xca, 0xa8, 0x2d, 0x27,
+      0x47, 0x60, 0x25, 0xe0, 0x8c, 0xda, 0x49, 0xf9, 0x1e, 0x22, 0xd8, 0xc0, 0x8e
+  };
+
   if (bgpsecInput == '\0')
   {
     bgpsec.numberHops = 0;
@@ -1402,8 +1438,19 @@ void doVerify(bool log, char** argPtr)
     bgpsec.asPath = NULL;
     bgpsec.attr_length = strlen(bgpsecInput)+1;
     bgpsec.bgpsec_path_attr = (uint8_t*)bgpsecInput;
+
+      /*
+    bgpsec.numberHops = 1;
+    bgpsec.asPath = aspath;
+    bgpsec.attr_length = 0x6d;
+    bgpsec.bgpsec_path_attr = (uint8_t*)bgpsec_pattr;
+    bgpsec.afi = htons(1);
+    bgpsec.safi = 1;
+    bgpsec.local_as = htonl(0xedfd0000);
+    */
   }
   
+  
   if (log)
   {
     if (bgpsec.attr_length == 0)
@@ -1487,6 +1534,7 @@ void handleSyncRequest()
   memset(buff, '\0', 46);
   sprintf(buff, "verify 0 3 65500 10.10.0.0/16 0 0 MyUpdateNo1");
   processLine(false, buff);
+  /*
   sprintf(buff, "verify 0 3 65501 10.20.0.0/17 0 2 MyUpdateNo2");
   processLine(false, buff);
   sprintf(buff, "verify 0 3 65502 10.30.0.0/18 1 2 MyUpdateNo3");
@@ -1495,14 +1543,17 @@ void handleSyncRequest()
   processLine(false, buff);
   sprintf(buff, "verify 0 1 65504 10.50.0.0/20 3 3 MyUpdateNo5");
   processLine(false, buff);
+  */
   LOG(LEVEL_DEBUG, "This update expects back a notification because SRx assumes"
                   " that the update might be stored using the new default"
                   " value. A notification is necessary to guarantee consistency"
                   " between SRx and ALL proxies!");
+  /*
   sprintf(buff, "verify 0 1 65504 10.50.0.0/20 0 0 MyUpdateNo5");
   processLine(false, buff);
   sprintf(buff, "verify 0 1 65504 10.60.0.0/21 3 3 MyUpdateNo6");
   processLine(false, buff);
+  */
   LOG(LEVEL_DEBUG, "This update expects back a notification because proxy "
                   " requested receipt!");
   sprintf(buff, "verify 0 1 65504 10.60.0.0/21 0 0 MyUpdateNo6");
@@ -1886,6 +1937,11 @@ bool processLine(bool log, char* line)
   else IF_EQ_DO(CMD_LOG_LEVEL, processLogLevel(&arg))
   else IF_EQ_DO(CMD_RESET_PROXY, resetProxy(&arg))
   else IF_EQ_DO(CMD_USE_NON_BLOCKING_SOCKET_TYPE, setSocketType(&arg))
+#ifdef USE_GRPC
+  else IF_EQ_DO(CMD_CONNECT_GRPC, doConnect_grpc(log, &arg))
+  else IF_EQ_DO(CMD_VERIFY_GRPC, doVerify_grpc(log, &arg))
+  else IF_EQ_DO(CMD_VERIFY_DB_GRPC, doVerify_db_grpc(log, &arg))
+#endif
     
   else
   {
@@ -1897,6 +1953,10 @@ bool processLine(bool log, char* line)
   return stop;
 }
 
+#ifdef USE_GRPC
+extern void ImpleGoStreamThread (SRxProxy* proxy, uint32_t proxyID);
+#endif
+
 /** The main program.*/
 int main(int argc, char* argv[])
 {
@@ -1905,7 +1965,8 @@ int main(int argc, char* argv[])
 
   // Set the target for the logging.
   setLogMethodToFile(stderr);  
-  setLogLevel(logLevel);
+  //setLogLevel(logLevel);
+  setLogLevel(7);
   // initialize the statistics framework
   fstatInitializeStatistics(false);
   uint32_t proxyID = IPtoInt(DEFAULT_PROXY_ID);
@@ -1916,6 +1977,18 @@ int main(int argc, char* argv[])
                          DEFAULT_PEERAS, // ProxyAS
                          NULL);
 
+#ifdef USE_GRPC
+  // initialize GRPC 
+  bool initResult = callSRxGRPC_Init("localhost:50000");
+  //proxy->grpcClientEnable = initResult;
+  printf("proxy: %p,  proxy ID [defaul]: %08x, grpcEnabled[%d]\n", proxy, proxyID, initResult);
+
+  g_proxy = proxy;
+
+  // NOTE: here some stream server threads
+  ImpleGoStreamThread(proxy, proxyID);
+#endif
+
   if (proxy == NULL)
   {
     RAISE_ERROR("Proxy could not be created. Abort program!\n");
@@ -1968,3 +2041,468 @@ int main(int argc, char* argv[])
   return 0;
 }
 
+#ifdef USE_GRPC
+void doConnect_grpc(bool log, char** argPtr)
+{
+  const char* input;
+  char*       host = NULL;
+  uint32_t    port;
+
+  int         noPeers      = 0;
+  int         peerLocation = 0;
+  int         size = sizeof(uint32_t);
+  uint32_t*   peerAS  = malloc(size); // space for one peer
+  uint32_t    peer = 0;
+  uint32_t    proxyID = IPtoInt(DEFAULT_PROXY_ID);
+
+  bool        connected;
+
+  char label[256]; // A 256 byte long buffer used as string buffer.
+  
+#if 0
+  // First check if the proxy is already connected.
+  if (isConnected(proxy))
+  {
+    printf("Disconnect first before calling connect!\n");
+    return;
+  }
+#endif
+
+  memset(label, 0, 256);
+  sprintf(label, "Host [default: '%s'] ? ", DEFAULT_SERVER);
+  // Get the parameters
+  input = prompt(argPtr, label);
+  if (strlen(input) > 0)
+  {
+    host = malloc(strlen(input)+1);   
+    memset(host, '\0', strlen(input)+1);
+    strcpy(host, input);
+  }
+    
+  memset(label, 0, 256);
+  sprintf(label, "Port [default: %d] ? ", DEFAULT_PORT);
+  port = promptU32(argPtr, label);
+  if (port == 0)
+  {
+    port = DEFAULT_PORT;
+  }
+
+  memset(label, 0, 256);
+  sprintf(label, "Proxy-id [default: %s] ? ", intToIP(proxy->proxyID));
+  proxyID = promptIPv4Int(argPtr, label);
+  if (proxyID == 0)
+  {
+    proxyID = proxy->proxyID;
+  }
+
+  memset(label, 0, 256);
+  sprintf(label, "PeerAS [default: %d] ? ", DEFAULT_PEERAS);
+  peer = promptU32(argPtr, label);
+  while (peer != 0)
+  {
+    noPeers++;
+    if (size < (noPeers * 4))
+    {
+      size = noPeers * 4;
+      peerAS = realloc(peerAS, size);
+    }
+
+    peerAS[peerLocation] = peer;
+    peerLocation++;
+    peer = promptU32(argPtr, "PeerAS (enter for stop) ? ");
+  }
+  if ((noPeers == 0) && (peer == 0))
+  {
+    peerAS[0] = DEFAULT_PEERAS;
+    noPeers++;
+  }
+
+#if 0
+  addPeers(proxy, noPeers, peerAS);
+#endif
+
+  if (log)
+  {
+    // Only the first peer is in history
+    if (noPeers > 0)
+    {
+      addToHistory("connect_grpc %s %u %u %u", host == NULL ? DEFAULT_SERVER : host, 
+                                          port, proxyID, peerAS[0]);
+    }
+    else
+    {
+      addToHistory("connect_grpc %s %u %u %u 0", host == NULL ? DEFAULT_SERVER 
+                                                         : host, 
+                                            port, proxyID, peerAS[0]);
+    }
+  }
+
+  if (proxy->proxyID != proxyID)
+  {
+    proxy->proxyID = proxyID;
+  }
+  connected = connectToSRx_grpc(proxy, host == NULL ? DEFAULT_SERVER : host, port, 
+                           SRX_DEFAULT_HANDSHAKE_TIMEOUT, !isBlocking);
+  printf ("Connection to %s %s\n", 
+           host == NULL ? DEFAULT_SERVER : host,
+           connected ? "is successfully established!" : "failed!");
+  if (host != NULL)
+  {
+    free(host);
+    host=NULL;
+  }
+  freshConnected = connected;
+}
+
+void doVerify_grpc(bool log, char** argPtr)
+{
+  uint32_t         localID;
+  uint32_t         as32;
+  const char*      prefixInput;
+  const char*      bgpsecInput;
+  IPPrefix         prefix;
+
+  uint8_t          method;
+
+
+  BGPSecData       bgpsec;
+  SRxASPathList    asPathList;
+
+  char ipString[255];
+  char* ipStringPtr = ipString;
+  memset(ipString,'\0',255);
+  
+  if (!isConnected(proxy))
+  {
+    printf ("Connect to SRx server prior verification request!\n");
+    return;
+  }
+  
+  ////////////////////////////////////////
+  /// READ PARAMETERS EITHER FROM COMMAND PATAMETER OR COMMAND LINE
+  ///////////////////////////////////////
+  // Receipt
+  localID = (uint32_t)promptU32(argPtr, "(Verify) Local ID: "
+                                        "[0=disable receipt] ? ");
+  // Method
+  method = (uint8_t)promptU32(argPtr, "(Verify) Method: "
+                                   "[0=just store, 1=Origin only, "
+                                   "2=Path only, 3=both] ? ");
+  if (method > 3)
+  {
+    printf ("Invalid Method %u\n", method);
+    return;
+  }
+
+  // Header data
+  as32  = promptU32(argPtr, "(Verify) AS number ? ");
+
+  // Prefix
+  prefixInput = prompt(argPtr, "(Verify) IP Prefix [] ? ");
+  if (!strToIPPrefix(prefixInput, &prefix))
+  {
+    printf("Error: Prefix [%s] is invalid\n", prefixInput);
+    return;
+  }
+  sprintf(ipStringPtr, "%s", prefixInput);
+
+
+  // Default result
+  SRxDefaultResult defResult;
+  defResult.result.roaResult = (uint8_t)promptU32(argPtr,
+                 "(Verify) DefOriginVal: [0=VALID, 1=UNKNOWN, 2=INVALID, "
+                 "3=Not Defined] ? ");
+  if (defResult.result.roaResult > 3)
+  {
+    printf("Error: Default origin validation result [%u] is invalid\n",
+           defResult.result.roaResult);
+    return;
+  }
+
+  defResult.result.bgpsecResult = (uint8_t)promptU32(argPtr,
+                         "(Verify) DefPathVal [0=VALID, 2=INVALID, "
+                         "3=Not Defined] ? ");
+  if (   (defResult.result.bgpsecResult > 3)
+      || (defResult.result.bgpsecResult == 1))
+  {
+    printf("Error: Default path validation result [%u] is invalid\n",
+           defResult.result.bgpsecResult);
+    return;
+  }
+
+  defResult.resSourceROA = SRxRS_UNKNOWN;
+  defResult.resSourceBGPSEC = SRxRS_UNKNOWN;
+
+  // @TODO: Generate some test data for input
+  bgpsecInput = prompt(argPtr, "(Verify) BGPSEC some string ? ");
+
+
+
+  /* 
+   *  on command line, "verify 1 3 65005 100.1.0.0/24 3 3" without bgpsec string,
+   *  then will fall into this following code
+   */
+  char basic_hd[] = {
+      0x03, 0x83, 0x01, 0x01, 0x00, 0x00, 0x00, 0xa9, 0x03, 0x03, 0x00, 0x18, 0x00, 0x00, 0x00, 0x01
+  };
+  char prefix_origin_bslength[] = {
+      0x64, 0x01, 0x00, 0x00, 0x00, 0x00, 0xfd, 0xf3, 0x00, 0x00, 0x00, 0x71
+  };
+  char bgpsec_ValReqData[] = {
+      0x00, 0x01, 0x00, 0x6d, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfd, 0xed
+  };
+  char aspath[] = {
+      0x00, 0x00, 0xfd, 0xf3,
+  };
+  char bgpsec_pattr[] = {
+      0x90, 0x21, 0x00, 0x69, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0xfd, 0xf3, 0x00, 0x61, 0x01, 0xc3,
+      0x04, 0x33, 0xfa, 0x19, 0x75, 0xff, 0x19, 0x31, 0x81, 0x45, 0x8f, 0xb9, 0x02, 0xb5, 0x01, 0xea,
+      0x97, 0x89, 0xdc, 0x00, 0x48, 0x30, 0x46, 0x02, 0x21, 0x00, 0xbd, 0x92, 0x9e, 0x69, 0x35, 0x6e,
+      0x7b, 0x6c, 0xfe, 0x1c, 0xbc, 0x3c, 0xbd, 0x1c, 0x4a, 0x63, 0x8d, 0x64, 0x5f, 0xa0, 0xb7, 0x20,
+      0x7e, 0xf3, 0x2c, 0xcc, 0x4b, 0x3f, 0xd6, 0x1b, 0x5f, 0x46, 0x02, 0x21, 0x00, 0xb6, 0x0a, 0x7c,
+      0x82, 0x7f, 0x50, 0xe6, 0x5a, 0x5b, 0xd7, 0x8c, 0xd1, 0x81, 0x3d, 0xbc, 0xca, 0xa8, 0x2d, 0x27,
+      0x47, 0x60, 0x25, 0xe0, 0x8c, 0xda, 0x49, 0xf9, 0x1e, 0x22, 0xd8, 0xc0, 0x8e
+  };
+
+  if (bgpsecInput == '\0')
+  {
+    bgpsec.numberHops = 0;
+    bgpsec.asPath = NULL;
+    bgpsec.attr_length = 0;
+    bgpsec.bgpsec_path_attr = NULL;
+  }
+  else
+  {
+      /* TODO: here, bgpsec struct variables are for the test purposes
+       *            Later should reflect from the user variables
+       *            for example, local_as need to be from a user input
+       */
+    bgpsec.numberHops = 1;
+    bgpsec.asPath = (uint32_t*) aspath;
+    bgpsec.attr_length = 0x6d;
+    bgpsec.bgpsec_path_attr = (uint8_t*)bgpsec_pattr;
+    bgpsec.afi = htons(1);
+    bgpsec.safi = 1;
+    bgpsec.local_as = htonl(0xedfd0000);
+  }
+
+  
+  if (log)
+  {
+    if (bgpsec.attr_length == 0)
+    {
+      addToHistory("verify_grpc %d %u %u %s %u %u %c" ,
+                   localID, method, as32, ipStringPtr,
+                   defResult.result.roaResult, defResult.result.bgpsecResult,
+                   '\0');
+    }
+    else
+    {
+      addToHistory("verify_grpc %u %u %u %s %u %u %s" ,
+                   localID, method, as32, ipStringPtr,
+                   defResult.result.roaResult, defResult.result.bgpsecResult,
+                   bgpsecInput);
+    }
+  }
+
+  //////////////////////////////////////////////////////////
+  //  Now send the message
+  //////////////////////////////////////////////////////////
+
+  if (localID != 0)
+  {
+    method = method | SRX_FLAG_REQUEST_RECEIPT;
+  }
+  
+  if (stat_started)
+  {
+    stat_requests_send++;
+  }
+
+  // The method verifyUpdate will go into wait mode if receipt is requested.
+  verifyUpdate_grpc(proxy, localID,
+               (method & SRX_FLAG_ROA) == SRX_FLAG_ROA,
+               (method & SRX_FLAG_BGPSEC) == SRX_FLAG_BGPSEC,
+               (method & SRX_FLAG_ASPA) == SRX_FLAG_ASPA,
+               &defResult, &prefix, as32, &bgpsec, asPathList);
+}
+
+
+void doVerify_db_grpc(bool log, char** argPtr)
+{
+  uint32_t         localID;
+  uint32_t         as32;
+  const char*      prefixInput;
+  const char*      bgpsecInput;
+  IPPrefix         prefix;
+
+  uint8_t          method;
+
+
+  BGPSecData       bgpsec;
+
+  char ipString[255];
+  char* ipStringPtr = ipString;
+  memset(ipString,'\0',255);
+  
+  if (!isConnected(proxy))
+  {
+    printf ("Connect to SRx server prior verification request!\n");
+    return;
+  }
+  
+  ////////////////////////////////////////
+  /// READ PARAMETERS EITHER FROM COMMAND PATAMETER OR COMMAND LINE
+  ///////////////////////////////////////
+  // Receipt
+  localID = (uint32_t)promptU32(argPtr, "(Verify) Local ID: "
+                                        "[0=disable receipt] ? ");
+  // Method
+  method = (uint8_t)promptU32(argPtr, "(Verify) Method: "
+                                   "[0=just store, 1=Origin only, "
+                                   "2=Path only, 3=both] ? ");
+  if (method > 3)
+  {
+    printf ("Invalid Method %u\n", method);
+    return;
+  }
+
+  // Header data
+  as32  = promptU32(argPtr, "(Verify) AS number ? ");
+
+  // Prefix
+  prefixInput = prompt(argPtr, "(Verify) IP Prefix [] ? ");
+  if (!strToIPPrefix(prefixInput, &prefix))
+  {
+    printf("Error: Prefix [%s] is invalid\n", prefixInput);
+    return;
+  }
+  sprintf(ipStringPtr, "%s", prefixInput);
+
+
+  // Default result
+  SRxDefaultResult defResult;
+  defResult.result.roaResult = (uint8_t)promptU32(argPtr,
+                 "(Verify) DefOriginVal: [0=VALID, 1=UNKNOWN, 2=INVALID, "
+                 "3=Not Defined] ? ");
+  if (defResult.result.roaResult > 3)
+  {
+    printf("Error: Default origin validation result [%u] is invalid\n",
+           defResult.result.roaResult);
+    return;
+  }
+
+  defResult.result.bgpsecResult = (uint8_t)promptU32(argPtr,
+                         "(Verify) DefPathVal [0=VALID, 2=INVALID, "
+                         "3=Not Defined] ? ");
+  if (   (defResult.result.bgpsecResult > 3)
+      || (defResult.result.bgpsecResult == 1))
+  {
+    printf("Error: Default path validation result [%u] is invalid\n",
+           defResult.result.bgpsecResult);
+    return;
+  }
+
+  defResult.resSourceROA = SRxRS_UNKNOWN;
+  defResult.resSourceBGPSEC = SRxRS_UNKNOWN;
+
+  // @TODO: Generate some test data for input
+  bgpsecInput = prompt(argPtr, "(Verify) BGPSEC some string ? ");
+
+
+
+  /* 
+   *  on command line, "verify 1 3 65005 100.1.0.0/24 3 3" without bgpsec string,
+   *  then will fall into this following code
+   */
+  char basic_hd[] = {
+      0x03, 0x83, 0x01, 0x01, 0x00, 0x00, 0x00, 0xa9, 0x03, 0x03, 0x00, 0x18, 0x00, 0x00, 0x00, 0x01
+  };
+  char prefix_origin_bslength[] = {
+      0x64, 0x01, 0x00, 0x00, 0x00, 0x00, 0xfd, 0xf3, 0x00, 0x00, 0x00, 0x71
+  };
+  char bgpsec_ValReqData[] = {
+      0x00, 0x01, 0x00, 0x6d, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfd, 0xed
+  };
+  char aspath[] = {
+      0x00, 0x00, 0xfd, 0xf3,
+  };
+  char bgpsec_pattr[] = {
+      0x90, 0x21, 0x00, 0x69, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0xfd, 0xf3, 0x00, 0x61, 0x01, 0xc3,
+      0x04, 0x33, 0xfa, 0x19, 0x75, 0xff, 0x19, 0x31, 0x81, 0x45, 0x8f, 0xb9, 0x02, 0xb5, 0x01, 0xea,
+      0x97, 0x89, 0xdc, 0x00, 0x48, 0x30, 0x46, 0x02, 0x21, 0x00, 0xbd, 0x92, 0x9e, 0x69, 0x35, 0x6e,
+      0x7b, 0x6c, 0xfe, 0x1c, 0xbc, 0x3c, 0xbd, 0x1c, 0x4a, 0x63, 0x8d, 0x64, 0x5f, 0xa0, 0xb7, 0x20,
+      0x7e, 0xf3, 0x2c, 0xcc, 0x4b, 0x3f, 0xd6, 0x1b, 0x5f, 0x46, 0x02, 0x21, 0x00, 0xb6, 0x0a, 0x7c,
+      0x82, 0x7f, 0x50, 0xe6, 0x5a, 0x5b, 0xd7, 0x8c, 0xd1, 0x81, 0x3d, 0xbc, 0xca, 0xa8, 0x2d, 0x27,
+      0x47, 0x60, 0x25, 0xe0, 0x8c, 0xda, 0x49, 0xf9, 0x1e, 0x22, 0xd8, 0xc0, 0x8e
+  };
+
+  if (bgpsecInput == '\0')
+  {
+    bgpsec.numberHops = 0;
+    bgpsec.asPath = NULL;
+    bgpsec.attr_length = 0;
+    bgpsec.bgpsec_path_attr = NULL;
+  }
+  else
+  {
+      /* TODO: here, bgpsec struct variables are for the test purposes
+       *            Later should reflect from the user variables
+       *            for example, local_as need to be from a user input
+       */
+    bgpsec.numberHops = 1;
+    bgpsec.asPath = (uint32_t*) aspath;
+    bgpsec.attr_length = 0x6d;
+    bgpsec.bgpsec_path_attr = (uint8_t*)bgpsec_pattr;
+    bgpsec.afi = htons(1);
+    bgpsec.safi = 1;
+    bgpsec.local_as = htonl(0xedfd0000);
+  }
+
+  
+  if (log)
+  {
+    if (bgpsec.attr_length == 0)
+    {
+      addToHistory("verify_grpc %d %u %u %s %u %u %c" ,
+                   localID, method, as32, ipStringPtr,
+                   defResult.result.roaResult, defResult.result.bgpsecResult,
+                   '\0');
+    }
+    else
+    {
+      addToHistory("verify_grpc %u %u %u %s %u %u %s" ,
+                   localID, method, as32, ipStringPtr,
+                   defResult.result.roaResult, defResult.result.bgpsecResult,
+                   bgpsecInput);
+    }
+  }
+
+  //////////////////////////////////////////////////////////
+  //  Now send the message
+  //////////////////////////////////////////////////////////
+
+  if (localID != 0)
+  {
+    method = method | SRX_FLAG_REQUEST_RECEIPT;
+  }
+  
+  if (stat_started)
+  {
+    stat_requests_send++;
+  }
+
+  // The method verifyUpdate will go into wait mode if receipt is requested.
+  int i;
+  for (i=0; i<100000; i++)
+  {
+      verifyUpdate_grpc(proxy, localID,
+                   (method & SRX_FLAG_ROA) == SRX_FLAG_ROA,
+                   (method & SRX_FLAG_BGPSEC) == SRX_FLAG_BGPSEC,
+                   &defResult, &prefix, as32, &bgpsec);
+  }
+}
+
+#endif
--- ./util/packet.c	2021-11-23 14:56:24.723374793 -0500
+++ ./util/packet.c	2021-11-22 21:25:23.381963602 -0500
@@ -212,7 +212,7 @@ bool receivePackets(int* fdPtr, SRxPacke
           pthread_self());
       // call the dispatcher that deals with the packet
       // TODO: Good point to have a receiver queue handing it over to.
-      dispatcher((SRXPROXY_BasicHeader*)buffer, pHandler);
+      dispatcher((SRXPROXY_BasicHeader*)buffer, pHandler); // --> call dispatchPackets()
     }
   }
 
--- ./util/server_socket.c	2021-11-23 14:56:24.724374799 -0500
+++ ./util/server_socket.c	2021-11-22 21:25:23.382963607 -0500
@@ -165,20 +165,30 @@ static void clientThreadCleanup(ClientMo
 static bool single_sendResult(ServerClient* client, void* data, size_t size)
 {
   ClientThread* clt = (ClientThread*)client;
+#ifdef USE_GRPC
+  bool retVal = false;
+#else
   bool retVal = true;
+#endif
+
+#ifdef USE_GRPC
+  if(!clt->type_grpc_client)
+#endif
+  {
   // Only when still active
   if (clt->active)
   {
     lockMutex(&clt->writeMutex);
     sendData(&clt->clientFD, data, (PacketLength)size);
     unlockMutex(&clt->writeMutex);
+      retVal = true;
   }
   else
   {
     RAISE_ERROR("Trying to send a packet over an inactive connection");
     retVal = false;
   }
-  
+  }
   return retVal;
 }
 
@@ -771,6 +781,9 @@ void runServerLoop(ServerSocket* self, C
         cthread->clientFD = cliendFD;
         cthread->svrSock  = self;
         cthread->caddr	  = caddr;
+#ifdef USE_GRPC
+        cthread->type_grpc_client = false;
+#endif
 
         ret = pthread_create(&(cthread->thread), &attr,
                              CL_THREAD_ROUTINES[clMode],
@@ -805,7 +818,10 @@ static void _killClientThread(void* clt)
   if (clientThread->active)
   {
     // Close the client connection
+#ifdef USE_GRPC
+    if(!clientThread->type_grpc_client)
     close(clientThread->clientFD);
+#endif
 
     // Wait until the thread terminated - if necessary
     //pthread_join(clientThread->thread, NULL);
@@ -887,3 +903,41 @@ int closeClientConnection(ServerSocket*
   return true;
 }
 
+
+
+
+#ifdef USE_GRPC
+static void* thread_ClientHandler_gRPC(void* clientThread)
+{
+  ClientThread* cthread = (ClientThread*)clientThread;
+
+  struct sigaction act;
+  sigset_t errmask;
+  sigemptyset(&errmask);
+  sigaddset(&errmask, SIGPIPE);
+  act.sa_handler = sigusr_pipe_handler;
+  sigaction(SIGPIPE, &act, NULL);
+  pthread_sigmask(SIG_UNBLOCK, &errmask, NULL);
+  g_single_thread_client_fd = cthread->clientFD;
+
+  LOG(LEVEL_DEBUG, "([0x%08X]) > gRPC Server Thread started ", pthread_self());
+  LOG(LEVEL_DEBUG, HDR "Inside new client thread, about to start traffic "
+                    "listener.", pthread_self());
+  if (initWriteMutex(cthread))
+  {
+      // TODO: procedure to dump data into buffer and then call
+      //   
+      // Start the receiver loop of this client connection.  
+      (void)receivePackets(&cthread->clientFD, single_packetHandler, cthread, 
+              PHT_SERVER);
+  }
+
+  clientThreadCleanup(MODE_SINGLE_CLIENT, cthread);
+  
+  LOG(LEVEL_DEBUG, "([0x%08X]) > Proxy Client Connection Thread stopped "
+                   "(ServerSocket::single_handleClient)", pthread_self());
+  
+  pthread_exit(0);
+}
+#endif
+
--- ./util/server_socket.h	2021-11-23 14:56:24.724374799 -0500
+++ ./util/server_socket.h	2021-11-22 21:25:23.382963607 -0500
@@ -263,6 +263,9 @@ typedef struct
   ServerSocket* svrSock;
   /* The socket address. */
   struct sockaddr caddr;  
+#ifdef USE_GRPC 
+  bool type_grpc_client; /* between general client and  grpc client */
+#endif
 } ClientThread;
 
 /**
@@ -332,5 +335,11 @@ int closeClientConnection(ServerSocket*
 // Maybe it can be moved into server_socket.c
 int g_single_thread_client_fd;
 
+#ifdef USE_GRPC
+void runServerLoop_gRPC(ServerSocket* self, ClientMode clMode,
+                   void (*modeCallback)(),
+                   ClientStatusChanged statusCallback,
+                   void* user);
+#endif // USE_GRPC
 #endif // !__SERVER_SOCKET_H__
 
--- ./config.h	1969-12-31 19:00:00.000000000 -0500
+++ ./config.h	2021-10-26 15:17:57.069535332 -0400
@@ -0,0 +1,181 @@
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Define to 1 if you have the <arpa/inet.h> header file. */
+#define HAVE_ARPA_INET_H 1
+
+/* Define to 1 if you have the <assert.h> header file. */
+#define HAVE_ASSERT_H 1
+
+/* Define to 1 if you have the <ctype.h> header file. */
+#define HAVE_CTYPE_H 1
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#define HAVE_DLFCN_H 1
+
+/* Define to 1 if you have the <errno.h> header file. */
+#define HAVE_ERRNO_H 1
+
+/* Define to 1 if you have the <fcntl.h> header file. */
+#define HAVE_FCNTL_H 1
+
+/* Define to 1 if you have the <getopt.h> header file. */
+#define HAVE_GETOPT_H 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the <malloc.h> header file. */
+#define HAVE_MALLOC_H 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the <netdb.h> header file. */
+#define HAVE_NETDB_H 1
+
+/* Define to 1 if you have the <netinet/in.h> header file. */
+#define HAVE_NETINET_IN_H 1
+
+/* Define to 1 if you have the <netinet/tcp.h> header file. */
+#define HAVE_NETINET_TCP_H 1
+
+/* Define to 1 if you have the <patricia.h> header file. */
+#define HAVE_PATRICIA_H 1
+
+/* Define to 1 if you have the <pthread.h> header file. */
+#define HAVE_PTHREAD_H 1
+
+/* Define to 1 if you have the <readline/history.h> header file. */
+#define HAVE_READLINE_HISTORY_H 1
+
+/* Define to 1 if you have the <readline/readline.h> header file. */
+#define HAVE_READLINE_READLINE_H 1
+
+/* Define to 1 if you have the <semaphore.h> header file. */
+#define HAVE_SEMAPHORE_H 1
+
+/* Define to 1 if you have the <signal.h> header file. */
+#define HAVE_SIGNAL_H 1
+
+/* Define to 1 if you have the <stdarg.h> header file. */
+#define HAVE_STDARG_H 1
+
+/* Define to 1 if stdbool.h conforms to C99. */
+#define HAVE_STDBOOL_H 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdio.h> header file. */
+#define HAVE_STDIO_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the <syslog.h> header file. */
+#define HAVE_SYSLOG_H 1
+
+/* Define to 1 if you have the <sys/socket.h> header file. */
+#define HAVE_SYS_SOCKET_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#define HAVE_SYS_TIME_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <sys/un.h> header file. */
+#define HAVE_SYS_UN_H 1
+
+/* Define to 1 if you have the <time.h> header file. */
+#define HAVE_TIME_H 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to 1 if you have the <uthash.h> header file. */
+#define HAVE_UTHASH_H 1
+
+/* Define to 1 if the system has the type `_Bool'. */
+#define HAVE__BOOL 1
+
+/* Define to the sub-directory in which libtool stores uninstalled libraries.
+   */
+#define LT_OBJDIR ".libs/"
+
+/* Name of package */
+#define PACKAGE "srx"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT "itrg-contact@list.nist.gov"
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "SRx"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "SRx 0.6.1.0"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "srx"
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL "https://www.nist.gov/services-resources/software/bgp-secure-routing-extension-bgp-srx-prototype"
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "0.6.1.0"
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* SRX GRPC */
+#define USE_GRPC /**/
+
+/* Version number of package */
+#define VERSION "0.6.1.0"
+
+/* pthread reentrant nature */
+#define _REENTRANT /**/
+
+/* Define for Solaris 2.5.1 so the uint32_t typedef from <sys/synch.h>,
+   <pthread.h>, or <semaphore.h> is not used. If the typedef were allowed, the
+   #define below would cause a syntax error. */
+/* #undef _UINT32_T */
+
+/* Define for Solaris 2.5.1 so the uint8_t typedef from <sys/synch.h>,
+   <pthread.h>, or <semaphore.h> is not used. If the typedef were allowed, the
+   #define below would cause a syntax error. */
+/* #undef _UINT8_T */
+
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef __cplusplus
+/* #undef inline */
+#endif
+
+/* Define to `unsigned int' if <sys/types.h> does not define. */
+/* #undef size_t */
+
+/* Define to `int' if <sys/types.h> does not define. */
+/* #undef ssize_t */
+
+/* Define to the type of an unsigned integer type of width exactly 16 bits if
+   such a type exists and the standard includes do not define it. */
+/* #undef uint16_t */
+
+/* Define to the type of an unsigned integer type of width exactly 32 bits if
+   such a type exists and the standard includes do not define it. */
+/* #undef uint32_t */
+
+/* Define to the type of an unsigned integer type of width exactly 8 bits if
+   such a type exists and the standard includes do not define it. */
+/* #undef uint8_t */
--- ./server/srx_server.conf	2021-11-23 14:56:24.718374765 -0500
+++ ./server/srx_server.conf	2021-11-22 21:25:23.377963579 -0500
@@ -1,5 +1,5 @@
 verbose  = true;
-loglevel = 5;
+loglevel = 6;
 #log     = "/var/log/srx_server.log";
 sync    = true;
 port    = 17900;
@@ -38,3 +38,8 @@ mapping: {
   client_10 = "10.0.0.1";
   client_25 = "10.1.1.2";
 };
+
+# default grpc port : 50000 even though it's not set
+grpc: {
+  port = 50000;
+};
